<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title>Lu Ying • Posts by &#34;作業系統小科普&#34; category</title>
        <link>https://lu1hoao.github.io</link>
        <description></description>
        <language>en</language>
        <pubDate>Thu, 09 Jun 2022 22:23:28 +0800</pubDate>
        <lastBuildDate>Thu, 09 Jun 2022 22:23:28 +0800</lastBuildDate>
        <category>OS</category>
        <category>scheduling</category>
        <category>Synchronization</category>
        <category>Deadlock</category>
        <category>Memory</category>
        <category>C</category>
        <category>combination</category>
        <category>sort</category>
        <category>permutation</category>
        <category>程式新手</category>
        <category>Visual studio 2022</category>
        <category>debug</category>
        <category>VS Code</category>
        <category>WSL</category>
        <category>Disk</category>
        <item>
            <guid isPermalink="true">https://lu1hoao.github.io/2022/06/09/os/os-15/</guid>
            <title>File System</title>
            <link>https://lu1hoao.github.io/2022/06/09/os/os-15/</link>
            <category>OS</category>
            <pubDate>Thu, 09 Jun 2022 22:23:28 +0800</pubDate>
            <description><![CDATA[ &lt;h3 id=&#34;概要&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#概要&#34;&gt;#&lt;/a&gt; 概要&lt;/h3&gt;
&lt;p&gt;本篇文章主要介紹 OS 處理檔案系統的方式，包含檔案架構、目錄、共享、保護，很多技術細節是前面章節所提過的，所以這單元也可以視為一種統整。&lt;/p&gt;
&lt;h3 id=&#34;file-attributes&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#file-attributes&#34;&gt;#&lt;/a&gt; File Attributes&lt;/h3&gt;
&lt;p&gt;電腦裡的檔案具有很多型態，可能是 Data ，包含數值、字元，也可能是執行檔、source file 等等，更詳盡的檔案資訊包含 Name、Indentfier、Type、Location、Size、Protection 甚至時間和 user identification ，具體須包含哪些內容，在不同作業系統中會有不同規定。我們可以從下表理解一些副檔名以及他們所代表的意義&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;file type&lt;/th&gt;
&lt;th&gt;usual extension&lt;/th&gt;
&lt;th&gt;function&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;exectutable&lt;/td&gt;
&lt;td&gt;exe,com,bin&lt;/td&gt;
&lt;td&gt;ready to run/machine-language program&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;object&lt;/td&gt;
&lt;td&gt;obj,o&lt;/td&gt;
&lt;td&gt;compiled,machine,language,not linked&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;source code&lt;/td&gt;
&lt;td&gt;c,cc,java,pas,asm,a&lt;/td&gt;
&lt;td&gt;source code in various languages&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;batch&lt;/td&gt;
&lt;td&gt;bat,sh&lt;/td&gt;
&lt;td&gt;commqands to the command interpreter&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;text&lt;/td&gt;
&lt;td&gt;txt,doc&lt;/td&gt;
&lt;td&gt;textual data,documents&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;word processor&lt;/td&gt;
&lt;td&gt;wp,tex,rtf,doc&lt;/td&gt;
&lt;td&gt;various word-processor formats&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;library&lt;/td&gt;
&lt;td&gt;lib,a,so,dll&lt;/td&gt;
&lt;td&gt;libraries of routines for programmers&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;print or view&lt;/td&gt;
&lt;td&gt;ps,pdf,jpg&lt;/td&gt;
&lt;td&gt;ASCII or binary file in a format for printing or viewing&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;file-operation&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#file-operation&#34;&gt;#&lt;/a&gt; File Operation&lt;/h3&gt;
&lt;p&gt;File 是一種抽象的資料型態，我們對她進行的常見操作有 create、write (at write poiinter)、read (at read pointer)、reposition within file (seek)、如果我們要 open file，OS 就會去 disk 中找 file 的位置，搬到 memory 中。一個 process open 的 file 會被紀錄在一個 file table 中，共享的檔案會記錄在 system file table 中，另外系統會提供 file-open counter 紀錄 file 被開啟的次數，如果有兩個 process 同時開啟一個 file，第一個 process 要關掉 file 了，他執行 close ，這時 file 應該會被存回 disk 中，但該 file 不能存回 disk，因為還有一個 process 在使用，也就是說當 file counter 的數字大於 1 的時候，關掉檔案時就要小心。&lt;br /&gt;
我們在 C 語言中使用以下程式碼來 open file&lt;/p&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption data-lang=&#34;c&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token macro property&#34;&gt;&lt;span class=&#34;token directive-hash&#34;&gt;#&lt;/span&gt;&lt;span class=&#34;token directive keyword&#34;&gt;include&lt;/span&gt;&lt;span class=&#34;token string&#34;&gt;&amp;lt;stdio.h&gt;&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token macro property&#34;&gt;&lt;span class=&#34;token directive-hash&#34;&gt;#&lt;/span&gt;&lt;span class=&#34;token directive keyword&#34;&gt;include&lt;/span&gt;&lt;span class=&#34;token string&#34;&gt;&amp;lt;fcntl.h&gt;&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt; &lt;span class=&#34;token keyword&#34;&gt;int&lt;/span&gt; f&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt; f&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;token function&#34;&gt;open&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;filename&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt;O_RDONLY&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token comment&#34;&gt;//READONLY&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;6&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;如果你在類 Unix 系統下，那就要在匯入  &lt;code&gt;&amp;lt;unistd.h&amp;gt;&lt;/code&gt; ，總之不同需求可能就會需要匯入不同 header ，建立新文件時，open 函數也需要三個引述才行，也可以使用  &lt;code&gt;fopen&lt;/code&gt; ，那會物件導向一點，在寫程式時最好也習慣加上檢查機制，不過這不是重點，需要時再去研究就行了。&lt;/p&gt;
&lt;h3 id=&#34;accessing-a-file&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#accessing-a-file&#34;&gt;#&lt;/a&gt; Accessing a File&lt;/h3&gt;
&lt;p&gt;存取 file 大致可以分為 Secquential access 和 Random access&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Sequential ：&lt;br /&gt;
依序存取，從頭開始讀取所有 byte ，如果使用磁帶或者需要整個程式資訊時這樣的做法就挺方便的，雖然不支援跳來跳去但有時可以倒回去讀 (move back)。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption data-lang=&#34;c&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;read next&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;write next&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;reset&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;ul&gt;
&lt;li&gt;Direct acess&lt;br /&gt;
 直接存取，適用於 database system&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption data-lang=&#34;c&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;read n&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;write n&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;position to n&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt; read next &lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt; write next&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;6&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;rewrite n&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;其中 n 是 block 的編號。&lt;br /&gt;
也有其他存取 file 的方式，像 IBM、VMS 就透過 index 來加快檔案存取速度，每份 data 都有自己的 index 表示他們的 logical record number ，index 資訊會被存在 memory 中，透過這些資訊到 disk 時尋找時間就可以大幅降低，概念上類似之前做的 paging。&lt;/p&gt;
&lt;h3 id=&#34;disk-structure&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#disk-structure&#34;&gt;#&lt;/a&gt; Disk Structure&lt;/h3&gt;
&lt;p&gt;disk 可以分成很多 partition ，每個 partition 的存取可以是 raw (without a file system) 像之前提過的 process image 的方式，也可以是 formatted 也就是透過 file system 的方式。&lt;br /&gt;
每個 partition 會有該 partition 的 direction (目錄) ，讓我們對 partition 存的資料有一些概覽，我們可以在 directory 中尋找檔案、建立檔案、刪除檔案等等。&lt;br /&gt;
最一開始使用的是 &lt;strong&gt;single-level directory&lt;/strong&gt; 也就是所有 user 共用一個目錄，舉例來說，電腦只有一個目錄，我在 &lt;strong&gt;桌面&lt;/strong&gt; 建立一個 a.txt 檔案，那我在 &lt;strong&gt;下載&lt;/strong&gt; 就不能建立 a.txt 檔案，沒有現在常見的路徑概念。所以之後又發展出樹狀結構目錄，像是 two (or three) level directory，把 directory 分成好幾個 user (第一層)，每個 user 下面又有自己的 file ，衍伸出了路徑概念，而且樹狀結構搜尋的時間複雜度是  &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mo stretchy=&#34;false&#34;&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo stretchy=&#34;false&#34;&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;log(n)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34; style=&#34;margin-right:0.03588em;&#34;&gt;g&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; ，也可以讓不同使用者建立同樣檔名的 file。&lt;br /&gt;
我們可以用下圖來理解 single level 和多 level 的差異&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://i.imgur.com/qW7HtrP.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;這是 single level，藍色部分是目錄，黃色部分是 file&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://i.imgur.com/VNyLqsm.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;這是 two-level directory ， 紫色是第一層目錄，藍色是第二層，代表不同使用者，黃色是不同使用者的 file&lt;br /&gt;
 有時會有兩個使用者都能存取同一 file 的狀態 (shared file)，這時我們會說這是 Acyclic-Grapg Directories。&lt;br /&gt;
另外在檔案管理中還有一個詞叫做 mounting 中文叫做安裝 (?) anyway 反正就是附著的概念，我們想在一個目錄底下存取一個檔案 (或一個子目錄)，我們必須把這些資料 mounting 到我們現在所處的位置。&lt;/p&gt;
&lt;h3 id=&#34;file-sharing&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#file-sharing&#34;&gt;#&lt;/a&gt; File Sharing&lt;/h3&gt;
&lt;p&gt;當我們要共享 file 時就必須考慮 protection，之前所講過的 lock 就是很好的方式，大部分檔案共享都是透過網路，稱為 Network File System (NFS)，在多 user 的存取中可以透過 User IDs 或 Group IDs 來確認存取者的身分和權限，NFS 是 UNIX 的 client-server file sharing protocol，CIFS 則是 Windows 標準的。在共享檔案系統中，確保檔案的正確也是很重要的一件事，檔案如果錯誤稱為 failure mode，我們會把一些錯誤的資料稱為 metadata，通常是指那些錯誤的目錄架構或非 user 的資料，另外我們有時也會紀錄檔案的狀態， (state information) 當我們想修復錯誤檔案，這些紀錄有助於我們復原到上一狀態，但如果沒有狀態資訊就只能全部清空。&lt;br /&gt;
在 consistency (同步) 部分，不同作業系統有不同做法，可以參考之前在講同步問題的章節。&lt;/p&gt;
&lt;p&gt;以上就是 file system 祝大家閱讀愉快&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://lu1hoao.github.io/2022/06/07/os/os-14/</guid>
            <title>I/O System</title>
            <link>https://lu1hoao.github.io/2022/06/07/os/os-14/</link>
            <category>OS</category>
            <pubDate>Tue, 07 Jun 2022 22:23:28 +0800</pubDate>
            <description><![CDATA[ &lt;h3 id=&#34;概要&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#概要&#34;&gt;#&lt;/a&gt; 概要&lt;/h3&gt;
&lt;p&gt;I/O System，輸入與輸出，是作業系統中很重要的一部份，本篇文章主要講述 I/O 如何與裝置和電腦溝通，以及在這過程中必須設想的各種情況。&lt;/p&gt;
&lt;h3 id=&#34;io-hardware&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#io-hardware&#34;&gt;#&lt;/a&gt; I/O Hardware&lt;/h3&gt;
&lt;p&gt;I/O 硬體有很多種類以因應不同需求，像是 Port 通常連接單一裝置，Bus - daisy chain 則可以連接很多裝置 (比如多螢幕)， 上述這些東西 (Bus、Port) 被 Controller (host adapter) 所控制。&lt;br /&gt;
I/O 透過指令傳達給與電腦連接的裝置，這些裝置通常會有 register 讓驅動程式放置命令、資料或位置，系統在處理 I/O 相關指令通常會有兩種手法，第一種就是建立專門的 I/O 指令，第二種則稱作 &lt;strong&gt;Memory-mapd I/O&lt;/strong&gt; ，這裡是把 I/O 指令視為 Memory 指令，呼叫裝置的資料會被存放在呼叫該裝置的程式的 address space 內，再用 memory 指令對其進行操控。&lt;/p&gt;
&lt;h3 id=&#34;外部裝置與電腦的溝通&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#外部裝置與電腦的溝通&#34;&gt;#&lt;/a&gt; 外部裝置與電腦的溝通&lt;/h3&gt;
&lt;p&gt;一台電腦可能同時有很多 device 想要做 I/O，滑鼠、鍵盤等等，那 I/O 要怎麼安排呢？有兩種做法，一種叫 polling ，一種是用 interrupt&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Polling&lt;/strong&gt;：&lt;br /&gt;
中文稱作輪巡，是 I/O 一個一個去詢問，一號裝置你好了嗎，如果好了 Host 就讀一號裝置的 data，然後開始執行一些動作， 在這步 controller 會把一號裝置的狀態設為 busy ，直到做完再恢復。這樣的作法又稱為 busy-wait cycle，又稱為 busy-wait cycle，想法雖然簡單易懂但實務上很少用，因為裝置要等待 I/O 來詢問才可以使用，這樣會使得 CPU 等太久，若 CPU 又換去做別的 task 也可能造成錯誤，總之會衍生出很多問題，所以現在多使用 interrupt。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Interrupt&lt;/strong&gt;&lt;br /&gt;
 每一個裝置想要使用 CPU ，就發出 interrupt，執行過程是這樣的，CPU 收到 interrupt 發送請求，確認後收到 interrupt，接著判斷該 interrupt 是否 maskable (可被遮蔽的)，如果不行就透過 interrupt vector 查找 interrupt vector table 找到相對應的處理方式，我們可以用下圖來理解&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img data-src=&#34;https://i.imgur.com/qt5pyIm.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;假設現在有個 proess 在執行過程中需要 disk 的資料，於是電腦上的驅動程式啟動 I/O ，disk 端也啟動 I/O (圖片右邊)，這時 I/O 開始讀資料，讀到以後發出 interrupt 給 CPU ，此時的 CPU 應該已經被 cotext switch 去做其他 task 了，CPU 收到 interrupt 把控制權交給 interrupt handler， 處理完之後，剛剛從 disk 中拿的資料已在 memory 中，CPU 又可以繼續執行該 process。&lt;/p&gt;
&lt;h3 id=&#34;diret-memory-access&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#diret-memory-access&#34;&gt;#&lt;/a&gt; Diret Memory Access&lt;/h3&gt;
&lt;p&gt;Direct Memory Access (DMA) 是為了避免以 program 形式的讀取 I/O ，透過 CPU 每次讀取一個 byte 的方式太慢了，當需要做大區塊資料般移的時候很沒效率，所以 DMA 可以繞過 CPU 直接對 mrmory 和 I/O 做存取。OS 會對 DMA 下指令，告訴他資料的位置與其他資訊，DMA 就直接從 A 地把資料搬到 B 地，換句話說  DMA 可以去搶 I/O bus，不過 DMA 和 CPU 都想搶 bus 要怎麼安排？早期是 DMA 叫 CPU 停下不要做了，現在則是使用 cycle stealing ，當 CPU 沒有要用 memory 時，DMA 就掌控 bus 。我們可以以下圖理解 (下圖文字很重要)&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://i.imgur.com/tktW7KT.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;h3 id=&#34;io-介面-os-支援&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#io-介面-os-支援&#34;&gt;#&lt;/a&gt; I/O 介面 &amp;amp; OS 支援&lt;/h3&gt;
&lt;p&gt;Kernel 必須提供一個統一的介面，內含各種豐富的功能以提供不同裝置對 I/O 的各種需求，I/O 應該要具有以下存取特性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Character-stream or bloock，意思是讀取時可以讀一個字也可以讀一整個區塊，比如鍵盤就是讀一個字，disk 是讀一個區塊。&lt;/li&gt;
&lt;li&gt;Sequential or random access，有次序或隨機存取&lt;/li&gt;
&lt;li&gt;Synchronous or asynchronous&lt;/li&gt;
&lt;li&gt;Sharable or dedicated&lt;br /&gt;
 我們可以用下表理解不同裝置對 I/O 的需求&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;aspect&lt;/th&gt;
&lt;th&gt;variation&lt;/th&gt;
&lt;th&gt;example&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;data-transer mode&lt;/td&gt;
&lt;td&gt;charactert/block&lt;/td&gt;
&lt;td&gt;terminal/disk&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;access method&lt;/td&gt;
&lt;td&gt;swquential/random&lt;/td&gt;
&lt;td&gt;modem CD-ROM&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;transfer schedule&lt;/td&gt;
&lt;td&gt;synchronous/asychronous&lt;/td&gt;
&lt;td&gt;table/keyboard&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;sharing&lt;/td&gt;
&lt;td&gt;dedicated/sharable&lt;/td&gt;
&lt;td&gt;tape/keyboard&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;另外系統需要 Memory mapped file access 以提高效率，在網路上則需要 Network sockets，而在 Unix 中就是使用 ioctl () 這個 system call 來送命令給 device control register 來執行 I/O 動作。&lt;br /&gt;
在即時系統中因為對時間非常要求，所以會週期性的產生 interrupt，需要 Programmable interval timer 來計時。&lt;br /&gt;
在執行 I/O 時也可以分成 Blocking 、 Non Blocking ，第一種是指 process 在執行到 I/O 時會暫停直到 I/O 好了，第二種則是藉由 multi-threading 來實現，一個 thread 去使用 I/O ，其他 thread 繼續跑，但會有 select ()、read ()、write () 來確認所需資料是否 ready ，不過後者通常不太好 debug ，因為時間很難抓，抓不好資料會出錯。我們用下圖理解 blocking 和 non-blocking ，左邊是 blocking ，process 會 wait ，右邊則是 non-blocking ，系統發出指令就不管了， process 繼續執行，過一段時間再來收 data。&lt;br /&gt;
在 Unix 中有個指令叫做 readve ()，意思是允許一次讀許多個 I/O 指令，稱為 vector I/O ，這樣的好處在於可以減少 CPU context switch 的次數，因為每碰到一次 I/O 就要 context switch ，會造成 overhead。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://i.imgur.com/fJst2YK.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;為了讓 I/O 有效率，OS 也需要提供各種支援，以下介紹六種&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;buffering ：&lt;br /&gt;
buffering 是為了協調各裝置的速度，有時候也會提供 double buffering，比如把網路上的資料先 copy 到 kernel 再 copy 到 user ，這樣比較穩健。&lt;/li&gt;
&lt;li&gt;caching ：&lt;br /&gt;
caching 這個字在不同領域有不同意思，通常是指 copy of data，有時會和 buffering 混用。&lt;/li&gt;
&lt;li&gt;spooling ：&lt;br /&gt;
spooling 是 hold output for a device，通常在裝置一次只能服務一人時，比如多台電腦連接同一台印表機，同時對該印表機下出影印指令，為了避免資料混印，就需要 spooling。&lt;/li&gt;
&lt;li&gt;device reservation：&lt;br /&gt;
就像之前說過的避免 deadlock 的一種方法，再需要之前把所有裝置都拿下。&lt;/li&gt;
&lt;li&gt;error handling：&lt;br /&gt;
通常在嘗試幾次失敗後會回傳錯誤代碼，比如網路常見的 404&lt;/li&gt;
&lt;li&gt;I/O protection：&lt;br /&gt;
通常 I/O 指令都是 privileged，也就是只能在 kernel 端執行，user 要通過 systemcall&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;kernel-data-structures&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#kernel-data-structures&#34;&gt;#&lt;/a&gt; Kernel Data Structures&lt;/h3&gt;
&lt;p&gt;不同的作業系統會有不同的看待 I/O 的方式，比如 windows 就是使用 messape passing 的方式， Unix 則是當作檔案系統來管理，我們以下圖理解&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://i.imgur.com/pJwCOSS.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;h3 id=&#34;小結&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#小結&#34;&gt;#&lt;/a&gt; 小結&lt;/h3&gt;
&lt;p&gt;I/O 是一個很複雜的章節，牽扯到很多硬體架構，除上述之外還有電源管理等等，不過很多觀念也是前面章節有提過的，本章重點還是在於 I/O 與硬體指令，I/O 指令如何傳給各種裝置、怎麼處理之間的問題，還有作業系統在這之間扮演的角色與提供的支援。&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://lu1hoao.github.io/2022/06/06/os/os-13/</guid>
            <title>Mass Storage System</title>
            <link>https://lu1hoao.github.io/2022/06/06/os/os-13/</link>
            <category>OS</category>
            <category>Disk</category>
            <pubDate>Mon, 06 Jun 2022 22:23:28 +0800</pubDate>
            <description><![CDATA[ &lt;h3 id=&#34;概要&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#概要&#34;&gt;#&lt;/a&gt; 概要&lt;/h3&gt;
&lt;p&gt;大容量儲存系統一般指的是 disk ，本文主要介紹 disk 的架構、連接 (attachment)、排程、管理，也講述 RAID 的基本知識。&lt;/p&gt;
&lt;h3 id=&#34;overview&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#overview&#34;&gt;#&lt;/a&gt; Overview&lt;/h3&gt;
&lt;p&gt;當我們提及硬碟 (HHD) 就會提到他的存取速度，硬碟存取速度由&lt;br /&gt;
硬碟旋轉到所需位置以及指針移動的時間有關，前者稱為 seek time，後者是 rotation lantency，兩者合稱 Positioning time，通常是微秒等級，disk 和電腦的連接則通常透過 I/O bus，在電腦端會有 Host controller 負責和 disk controller 溝通&lt;br /&gt;
 SSD 則是支援隨機存取的 disk ，但通常有固定的寫入次數，因此 SSD controler 要讓每個地方的讀取平均避免壞掉。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://i.imgur.com/R5zSz80.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;h3 id=&#34;disk-structure&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#disk-structure&#34;&gt;#&lt;/a&gt; Disk Structure&lt;/h3&gt;
&lt;p&gt;disk 的基本讀取單位是 logical block，資料會被分成多個 block 然後對應到相應的 sector 中，因此當資料放在近一點的位置，他們的存取速度也會比較快。很多個 disk 合在一起可以形成 disk array ，比如跨國企業的資料可以存放在 disk array 再透過 switch、routing 技術連結到 severr，現在也發展出 Network-Attached Storage ，讓個人存放在 disk array 的資料也可以透過網路連接到筆電、平版等各種裝置 。&lt;/p&gt;
&lt;h3 id=&#34;disk-scheduling&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#disk-scheduling&#34;&gt;#&lt;/a&gt; Disk Scheduling&lt;/h3&gt;
&lt;p&gt;作業系統有責任確保硬體的存取效率，對 disk 而言那意味著作業系統要有一套好的排程系統使得 seek time 最短，而 seek time 又和 seek distance 直接相關，因此衍生出以下幾種排程&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;FCFS&lt;br /&gt;
 假設現在指標在 sector 53，而需要存取的資訊分別在 98、183、37、122、14、124、65、67，FCFS 顧名思義就是先來的先處理，別管甚麼距離最佳化了，這樣做的好處在於當資料之間有因果關係時，依然能保持他們的次序而不會出錯，執行過程如下圖，總距離是 640 cylinder&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img data-src=&#34;https://i.imgur.com/adIyUhK.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SSTF&lt;br /&gt;
 距離最短的先取得，但這個過程會破壞原本的次序，依照上面的例子，總距離是 236 cylinder，執行過程如下圖&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img data-src=&#34;https://i.imgur.com/L4CA8zZ.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SCAN&lt;br /&gt;
scan 的中文稱作掃描，意思即從頭到尾走一遍遇到所需的資料就執行動作，當資料很分散時這樣的做法就很好，以下是 scan 的執行過程&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img data-src=&#34;https://i.imgur.com/YavSUMx.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;C-SCAN&lt;br /&gt;
 一種改良版 scan，當從最後一個位置跑到第一個位置時 (或相反) 可以對走過的路徑加速，執行過程如下&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img data-src=&#34;https://i.imgur.com/yB9eUnP.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;C-LOOK&lt;br /&gt;
 改良版 C-SCAN ，不只對走過的路徑加速，也優先判斷所需資料中的最大與最小編號，比最小編號小或比最大編號大的位置就不走訪。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img data-src=&#34;https://i.imgur.com/Pu4xdX1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;h3 id=&#34;disk-management&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#disk-management&#34;&gt;#&lt;/a&gt; Disk Management&lt;/h3&gt;
&lt;p&gt;low-level formatting or formatting 中文稱作格式化，會把 disk 分成很多個 sector，由 disk controller 以 sector 為單位的管理，而 OS 為了管理 disk 也會在 disk 中擁有自己的 data structure ，假如我們想在自己的筆電上弄個 D 槽出來就可以透過格式化達成，但筆電出廠時通常已經灌好作業系統，所以除非把作業系統卸載之後再自己裝否則還是無法格式化。&lt;br /&gt;
開機程式存於 ROM 而 Bootstrap loader program 則存在 disk 中的 boots blocks。另外 sector 也要有辦法處理 bad block&lt;br /&gt;
 在虛擬記憶體中我們說過 disk 中會有 proess 的 image ，當 process 被啟用時，時間 swap ，而不必透過檔案系統，存放這些 image 的地方就稱為 swap space ，通常包含程式的 code、text segment，而 kernel 則是透過 swap maps 去追蹤 swap space 的使用情形，如果 swap space 用完了，大部分系統會出現警告。&lt;/p&gt;
&lt;h3 id=&#34;raid-structure&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#raid-structure&#34;&gt;#&lt;/a&gt; RAID Structure&lt;/h3&gt;
&lt;p&gt;RAID 的中文稱作磁碟陣列，在 RAID 尚未被發明之前，都是以單台硬碟作為使用，當第一台硬碟滿後必須加裝第二、三台，在各台硬碟間來回切換非常不方便，RAID 的核心架構就是虛擬架構，透過多台硬碟合成一台虛擬硬碟，而 RAID 也背負著其他要求，像是自動偵測故障硬碟、備份等等。我們通常會用 men time to failure (mttf)、mean time to repair、mean time to data loss 來評估 RAID 的效能， Raid 的資本單位是 disk striping，又可以分成六級&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RAID 0 一般的 RAID，NO COPY、NO PARITY (錯誤容忍)&lt;/li&gt;
&lt;li&gt;RAID mirrired disks，RAID 1 的每一個 disk 都有一份 copy 作為備份&lt;/li&gt;
&lt;li&gt;RAID 2、3、4 現在都很少用&lt;/li&gt;
&lt;li&gt;RAID 5、6 則是分散 parity，容許故障。&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Arrael Level&lt;/th&gt;
&lt;th&gt;RAID 0&lt;/th&gt;
&lt;th&gt;RAID 1&lt;/th&gt;
&lt;th&gt;RAID 5&lt;/th&gt;
&lt;th&gt;RAID5+Spare&lt;/th&gt;
&lt;th&gt;RAID 6+Spare&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Fault Tolerance&lt;/td&gt;
&lt;td&gt;NO&lt;/td&gt;
&lt;td&gt;容許一台故障&lt;/td&gt;
&lt;td&gt;容許一台故障&lt;/td&gt;
&lt;td&gt;容許兩台故障 (非同步)&lt;/td&gt;
&lt;td&gt;容許兩台故障 (非同步)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;硬碟台數&lt;/td&gt;
&lt;td&gt;2 (以上)&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;3 (以上)&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Array Size&lt;/td&gt;
&lt;td&gt;N-1&lt;/td&gt;
&lt;td&gt;N/2&lt;/td&gt;
&lt;td&gt;N-1&lt;/td&gt;
&lt;td&gt;N-2&lt;/td&gt;
&lt;td&gt;N-3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;適用對象&lt;/td&gt;
&lt;td&gt;風險高 NO&lt;/td&gt;
&lt;td&gt;個人&lt;/td&gt;
&lt;td&gt;企業&lt;/td&gt;
&lt;td&gt;企業&lt;/td&gt;
&lt;td&gt;企業&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;結語&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#結語&#34;&gt;#&lt;/a&gt; 結語&lt;/h3&gt;
&lt;p&gt;disk 的應用與硬體的架構較相關，隨著硬體技術的進步、disk 容量可以越來越大、價格可以越來越便宜，在 stable sorage 中，要確保資料穩定儲存，就是排除錯誤，一旦發現可能產生的錯誤就不更改 sector 內容，總而言之這章在 OS 中並沒有占很大篇幅，技術細節也應該是電機 (？) 領域，祝大家閱讀愉快。&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://lu1hoao.github.io/2022/05/29/os/os-12/</guid>
            <title>Virtual Memory (下)</title>
            <link>https://lu1hoao.github.io/2022/05/29/os/os-12/</link>
            <category>OS</category>
            <category>Memory</category>
            <pubDate>Sun, 29 May 2022 22:23:28 +0800</pubDate>
            <description><![CDATA[ &lt;h3 id=&#34;概要&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#概要&#34;&gt;#&lt;/a&gt; 概要&lt;/h3&gt;
&lt;p&gt;本篇文是 virtual memory 的最後一篇 (終於) 主要說明 Allocation of Frame 的不同方法以及這隻中會遇到的問題，並提及 Memory-Mapped Files 的概念&lt;/p&gt;
&lt;h3 id=&#34;allocation-of-frames&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#allocation-of-frames&#34;&gt;#&lt;/a&gt; Allocation of Frames&lt;/h3&gt;
&lt;p&gt;在分配 frame 的理論中有一種稱為 &lt;strong&gt;Fixed Allocation&lt;/strong&gt; ，即該 process 在執行之前就已經知道自己可以拿到幾個 frame ，fixed allocation 又可以分為 &lt;strong&gt;equal allocation&lt;/strong&gt; 和 &lt;strong&gt;prpportional allocation&lt;/strong&gt; 前者是每個 process 都拿到相同數目的 frame ，後者是根據 process 大小調整分配到的 frame 數目，另外系統通常會保留一些 free frame 在 free frame buffer pool，以備不時之需。&lt;br /&gt;
除了 Fixed Allocation 還有一種稱為 &lt;strong&gt;Prioroity Allociation&lt;/strong&gt; ，當優先權較高的 process frame 不夠時，可以拿取低優先權 process 的 frame ，又稱為 Global replacement ，這樣做會讓程式每次執行的時間都不太一樣，低優先權程式可能跑好久才跑完，但產率較高。&lt;br /&gt;
在具有 non-uniform memory access 的系統中，則發展出 lgroups 的概念，把鄰近的 CPU 和 memory 組成群組，群組內可使用自己的排成和 paging 演算法，稱為 &lt;strong&gt;low latency groups&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;trashing&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#trashing&#34;&gt;#&lt;/a&gt; Trashing&lt;/h3&gt;
&lt;p&gt;a process is busy swapping pages in and out 就稱為 Trashing，Trashing 的主因是因為太多 process 在 memory 中，造成每個 process 分到的 page frame 很少，產生很多 page fault，然而當這種情況發生時 CPU 的使用率會非常低，作業系統發現 CPU 使用率低又派發更多 process 導致不斷的惡性循環，我們以下方流程說明&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;page fault to get page&lt;/li&gt;
&lt;li&gt;replace existing frame&lt;/li&gt;
&lt;li&gt;but quickly need replaced frame block&lt;/li&gt;
&lt;li&gt;another process added to the system&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;那 trashing 最常發生在甚麼時候呢？我們前面說過 demand paging 最重要的觀念就是執行時，放需要的程式碼進來就好，不會互相影響的區段放在 disk 也沒關係，假設現在有一個 process 由三個大迴圈組成，那 trashing 最容易發生在迴圈交界處，從第一個迴圈要跑到第二個迴圈時，所需的資料量橫跨第一個迴圈所屬的 page 和第二個迴圈所屬的 page 因此容易造成 page fault 。&lt;/p&gt;
&lt;h3 id=&#34;working-set-model&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#working-set-model&#34;&gt;#&lt;/a&gt; Working-set Model&lt;/h3&gt;
&lt;p&gt;我們使用 Working-set Model 來監看 trashing 是否會發生，核心概念是這樣：先訂出一段時間範圍，稱為 working set window ，看看在這段時間內有幾個 page 被 reference ，假設有 7 個，但所給予的 page frame 只有 4 個，那就容易造成 trashing。&lt;br /&gt;
在做實驗的時候我們又是如何判斷這個 page 有沒有被 reference 呢？假設 working set window 是 10000 ns ，我給與每個 page 10 個 bit ，每一千秒的時候檢查一次，如果這個 page 被 reference 那就把對應到的 bit 設為 1 ，(比如四千秒時，編號 7 被 reference ，那編號 7 的第 4 個 bit 即為 1)，結束後，若該 page 有超過 5 個 bit 為 1 那我們就說該 page 在 working sets 裡面。&lt;br /&gt;
然而使用 working sets 來監測 trashing 有點麻煩，所以實務上會使用 &lt;strong&gt;Page-Fault Frequency&lt;/strong&gt; 的概念，系統會設定一個 page fault 上限，若現在產生的 page fault 遠高於這個上限，那就趕快增加 page frame 給 process ，直到達到一個可以接受的範圍&lt;/p&gt;
&lt;h3 id=&#34;memory-mapped-file&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#memory-mapped-file&#34;&gt;#&lt;/a&gt; Memory Mapped File&lt;/h3&gt;
&lt;p&gt;memory mapped file I/O 是把 disk 中的 page 放到 memory 中，之後若對這個文件有甚麼更動，就相對於在記憶體中做更動，速度會快很多，在做更動之中也不需要立刻把解果從 memory 寫回 disk 中，關掉時在一次儲存就可以了，不過值得注意的是，在 mapping 到 memory 的過程中，是存放在 kernel 的 address space ，所以是耗掉 kernel 的記憶體。&lt;/p&gt;
&lt;h3 id=&#34;slab-allocator&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#slab-allocator&#34;&gt;#&lt;/a&gt; Slab Allocator&lt;/h3&gt;
&lt;p&gt;許多處理器架構上，系統每次分配記憶體都以 page 為單位，但系統執行時大部分資料結構都很小，為一個小物件分配一個 page 會造成很多 internel fragmentation ，所以 Linux 中使用 slab ，slab 把 page 切割成小塊在零售出去，而 cache 則是多個 slab ，kernel 的物件會存放在 cache 裡頭，我們以下圖理解&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://i.imgur.com/rS1DpQB.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;一個 pgae 被切成 4 個 slab ，每一個 cache 含有 8 個 slab 而 kenel object 就存放在 cache 中。&lt;/p&gt;
&lt;p&gt;以上就是 virtual memory 的最終章，祝大家閱讀愉快&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://lu1hoao.github.io/2022/05/29/os/os-11/</guid>
            <title>Virtual Memory (中)</title>
            <link>https://lu1hoao.github.io/2022/05/29/os/os-11/</link>
            <category>OS</category>
            <category>Memory</category>
            <pubDate>Sun, 29 May 2022 09:14:45 +0800</pubDate>
            <description><![CDATA[ &lt;h3 id=&#34;概要&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#概要&#34;&gt;#&lt;/a&gt; 概要&lt;/h3&gt;
&lt;p&gt;本篇文章主要講述 Page Replacement Policy 探討不同 replacement 的演算法有怎麼樣的差異，又是如何借助一些硬體輔助來實現。&lt;/p&gt;
&lt;h3 id=&#34;page-replacement&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#page-replacement&#34;&gt;#&lt;/a&gt; Page Replacement&lt;/h3&gt;
&lt;p&gt;當 CPU 所需的 page 不在 memory 中，而 memory 中也沒有屬於該 process 的 free frame ，就必須把其中一個不需要的 page 清掉，換需要的 page 進來。舉例來說假設每個 process 都有 3 個 frame 可以用，現在 A process 的 3 個 frame 分別裝了編號 7、 5、 4  的 page ，而需要編號 2 的 page ，那就必須清空 7、5、4 中的其中一個，把編號 2 搬進來，流程如下&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;找到所需 page 在 disk 中的位置 (這裡為編號 2 的 page)&lt;/li&gt;
&lt;li&gt;尋找 free frame&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;若記憶體中本來就有 free frame 那就直接使用&lt;/li&gt;
&lt;li&gt;若記憶體中沒有 free frame ，那就選一個受害者，把它清掉。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;把需要的 page 搬進來&lt;/li&gt;
&lt;li&gt;繼續執行&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;當所需的 page 不在記憶體中即產生 page fault。沒有 free frame 而必須把現有的 page 清掉，這個過程也必須考慮該 page 內容有沒有被修改過，如果有，我們必須先把他的新內容儲存到 disk 中再清掉，如果沒有，直接把待用的 page 覆蓋上去就可以了，為了記錄是否被修改過，在 page table 中的每一項 (即每一個 page) 都有一個 &lt;strong&gt;modify bit&lt;/strong&gt; 。&lt;br /&gt;
至於該選哪一個 page 被換掉，就是由 page-replacement algorithm 決定，不同演算法會有不同結果，但共同目標都是希望所造成的 page fault 最小。&lt;/p&gt;
&lt;h3 id=&#34;first-in-first-out-algorithm-fifo&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#first-in-first-out-algorithm-fifo&#34;&gt;#&lt;/a&gt; First In First Out Algorithm (FIFO)&lt;/h3&gt;
&lt;p&gt;我們使用一個 reference string 來模擬，reference string 就是一個紀錄哪一個 page (編號) 被使用的字串，並假設每一個 process 都只有三個 frame 可以用，FIFO 的意思就是先進來的先出去，最早進到 frame 的 page 最先出去，我們以下圖來說明，假設 reference string 是&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;katex-display&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34; display=&#34;block&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;7&lt;/mn&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;7,0,1,2,0,3
&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8388800000000001em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;7&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;那對應到的 page frame 狀態就會長這樣&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://i.imgur.com/8bBFgL8.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;造成 5 個 page fault ，事實上使用 FIFO 演算法還會造成 Belady&#39;s Anomaly, 再給予更多 page frame 的狀態下反而可能造成更多 page fault&lt;/p&gt;
&lt;h3 id=&#34;optimal-algorithm&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#optimal-algorithm&#34;&gt;#&lt;/a&gt; Optimal Algorithm&lt;/h3&gt;
&lt;p&gt;optimal 是最佳的，但實際上我們無法做出最佳的演算法，所以它是一個標準，當我們想要評估一個演算法的好壞時，就拿他跟最佳的演算法比。optimal alogorithm 是置換掉未來最晚被使用到的 page ，舉例來說&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;katex-display&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34; display=&#34;block&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;7&lt;/mn&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mn&gt;4&lt;/mn&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;7,0,1,2,0,3,0,4,2,3,0,3,2,1
&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8388800000000001em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;7&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;使用 FIFO 在 4 的這個位置，frame 狀態是 (4,3,0)，把 2 換掉，但 optimal 卻是 (2,4,3) 把零換掉，因為零相比 2、3 會更晚才使用到。 optimal 是察看未來的情況做決定，但我們實際上無法預知未來，所以才說 optimal 是做不到的。&lt;/p&gt;
&lt;h3 id=&#34;least-recently-used-lru-algorithm&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#least-recently-used-lru-algorithm&#34;&gt;#&lt;/a&gt; Least Recently Used (LRU) Algorithm&lt;/h3&gt;
&lt;p&gt;雖然無法查看未來，但我們可以記錄過去，LRU 就是基於這樣的想法，所以是置換掉過去最長一段時間沒被使用的 page，而 LRU 和 OPT (optimal) 都是沒有 Bleady&#39;s Anomaly ，也就是說給越多 page frame 越不容易產生 page fault。&lt;br /&gt;
那要如何實作 LRU 呢？這裡提供兩個想法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Counter implementation&lt;/strong&gt;&lt;br /&gt;
 每一個 page 都配有一個 clock ，記錄他被 reference 的時間，然後把這個時間複製到 counter ，當要置換時就挑選時間最小的。這樣有一個缺點就是每次置換時都必須搜尋整個 table ，有點浪費時間&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Stack implementation&lt;/strong&gt;&lt;br /&gt;
 另一個方法是使用類似 stack 的資料結構，但和 stack 有點不同，這個方法是指 process 配有一個 stack ，當該 page 被 reference 時，就移到 stack 的 top ， 要置換時則選擇 stack 最底部的 page&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;lru-approximation-algorithm&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#lru-approximation-algorithm&#34;&gt;#&lt;/a&gt; LRU Approximation Algorithm&lt;/h3&gt;
&lt;p&gt;因為 LRU 需要特別的硬體支援，速度還是偏慢，所以誘發產出了其他方法，希望效果能盡量接近 LRU&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;reference bit&lt;/strong&gt;&lt;br /&gt;
reference bit 是記錄這個 page 近期也沒有被用到，因此他的值會定時檢查，當需要置換時就優先選擇 reference bit 為 0 的 page，然而我們並不能從 reference 的值得知 page 被 reference 的順序&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Second Chance Algorithm&lt;/strong&gt;&lt;br /&gt;
 這是基於 FIFO 的演算法，不過多了 reference bit 的幫忙，每次要置換時，如果現在輪到的那一個 (最早進來的那一個) 的 reference bit 為 0，那很好直接至換掉他，若他為 1 ，就把它改成 0 ，然後置換掉下一個 (第二早進來的)，這個演算法還有另一種改良，就是除了配有 reference bit 以外，還配有 modify bit 紀錄該 page 是否被修改過，置換時應優先考慮 reference bit 和 modify bit 皆為 0 (最近沒被使用也沒被修改) 的 page 。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;小節&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#小節&#34;&gt;#&lt;/a&gt; 小節&lt;/h3&gt;
&lt;p&gt;以上就是本篇文的內容，更多關於 Allocation of frame 的內容在下篇喔！祝大家閱讀愉快！&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://lu1hoao.github.io/2022/05/27/os/os-10/</guid>
            <title>Virtual Memory (上)</title>
            <link>https://lu1hoao.github.io/2022/05/27/os/os-10/</link>
            <category>OS</category>
            <category>Memory</category>
            <pubDate>Fri, 27 May 2022 21:23:28 +0800</pubDate>
            <description><![CDATA[ &lt;h3 id=&#34;概要&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#概要&#34;&gt;#&lt;/a&gt; 概要&lt;/h3&gt;
&lt;p&gt;本篇文章主要講述 Virtual memory 的管理，討論放在 Virtual memory 的資料如何被搬運至 main memory ，再拿取過程中會碰到甚麼問題又該如何解決，簡而言之就是討論 demand paging 。&lt;/p&gt;
&lt;h3 id=&#34;背景&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#背景&#34;&gt;#&lt;/a&gt; 背景&lt;/h3&gt;
&lt;p&gt;所謂的 virtual memory 指的是 disk ，當一個程式被執行時，他所用到的 data 都應被放在 main memory 中，可是某些程式很大，如果要把整個程式放到 memory 很佔空間，在做 context switch 時也很花時間。因此產生了 virtual memory 的想法，把程式分成很多個 page ，把這些 page 先存在 disk ，需要用他時再把單一個 page 從 disk 搬到 memory 中。&lt;br /&gt;
我們可以用下圖來理解&lt;br /&gt;
&lt;img data-src=&#34;https://i.imgur.com/5HPOkzv.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;電腦轉換步驟如下&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;CPU 把 logical arddress 傳給 MMU&lt;/li&gt;
&lt;li&gt;MMU 去該 process 的 page table 找相對應的 frame number (page table 在 memory 中)&lt;/li&gt;
&lt;li&gt;發現在 page table 中該 page 的 valid bit 為零，表示該 page 的資訊還沒被放入 memory&lt;/li&gt;
&lt;li&gt;page table 中有一個指標指到 disk 中該 page 的位置&lt;/li&gt;
&lt;li&gt;到 disk 去把他載入&lt;/li&gt;
&lt;li&gt;CPU 開始執行&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在程式開始執行的那一刻，PCB 已建好，但所有的 page 都還未放入 memory ，直到 CPU 要執行發現 哇！怎麼都沒東西，這時候再去 disk 拿，而這個現象稱為 &lt;strong&gt;page fault&lt;/strong&gt; 拿完之後再回來跟 CPU 說我好了，你可以繼續執行了。&lt;br /&gt;
可以這麼做的原因是因為我們可以把程式分成很多部分，不同部分之間若關聯性不大，那在執行時有沒有把全部都放到 memory 就不重要，稱為程式的 &lt;strong&gt;locality of reference&lt;/strong&gt;。但如果寫程式時規劃得不太好，把彼此有關聯的程式寫在相距很遠的地方，導致他們無法儲存在同一個 page ，執行時產生很多 page fault，我們就稱為 &lt;strong&gt;thrashing&lt;/strong&gt;&lt;br /&gt;
 所以 virtual mamory 的優點有以下幾個&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;program 大小不受記憶體大小限制&lt;/li&gt;
&lt;li&gt;更多的 program 可以同時放到記憶體內 (因為每個 program 佔的空間變小)&lt;/li&gt;
&lt;li&gt;CPU 使用率、產能、回應時間都變好&lt;/li&gt;
&lt;li&gt;I/O 比較少 (因為部分程式碼產生的 I/O 應該會比全部程式碼產生的 I/O 少)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我們把該 program 存在 memory 的部分稱為 resident set ，resident set 大小會影響到可以放幾個 program 在 memory 中。&lt;/p&gt;
&lt;h3 id=&#34;demand-paging&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#demand-paging&#34;&gt;#&lt;/a&gt; Demand Paging&lt;/h3&gt;
&lt;p&gt;上一段解釋了 virtual memory 的觀念後，這一段要來說明更細節的注意事項。在 virtual memory 中，page table 會有一個 valid bit 表示這個 page 的狀態，valid 是 1 表示這個 page 在記憶體中，請到相對應的 frame 去取他，若 valid bit 為 0 則表示 page 不在 memory 中或者你存取到別人的位置了，這兩種情況會產生不同的 system call ， OS 也會做相對應的處理。如果是前者，那麼該 process 會被放到 blocking state ，CPU 先去做其他程式，而 OS 也不是透過一般的檔案系統去拿取 disk 中的資料，而是透過 swap 技術，執行這種行為的 swaper 又稱 &lt;strong&gt;Lazy swapper&lt;/strong&gt;、&lt;strong&gt;pager&lt;/strong&gt;，等到所需資料拿到了，CPU 再回頭繼續做這個程式。我們可以用以下圖片說明&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://i.imgur.com/yVbebtW.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;在開始執行之初，尚未在 memory 放入任何 page ，這種 demand paging 稱為 &lt;strong&gt;pure demand paging&lt;/strong&gt;，在同一個指令中也可能隱含著多個 page fault ，比如指令 move m1 to m2 ，可能 m1 、m2 分屬不同 page 兩個也都不在記憶體中，稱為 multiple page fault，為了避免過多的 page fault (因為到 disk 很花時間) locality reference 就很重要 (把會互相影響的東西放在一起)，從 disk 拿完資料回來後也要記得修改 valid bit&lt;/p&gt;
&lt;h3 id=&#34;performance-of-demand-paging&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#performance-of-demand-paging&#34;&gt;#&lt;/a&gt; Performance of Demand Paging&lt;/h3&gt;
&lt;p&gt;前面一直說 page fault 很花時間，這裡就用實例來看看，假設 memory access time 是 200 ns，有 page fault 時的拿取時間是&lt;br /&gt;
 8000000 ns，有 p 成的機率會產生 page fault ，那麼 effective access time 會變成&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;katex-display&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34; display=&#34;block&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo stretchy=&#34;false&#34;&gt;(&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mo stretchy=&#34;false&#34;&gt;)&lt;/mo&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;mn&gt;200&lt;/mn&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;mn&gt;8000000&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;(1-p)*200+p*8000000
&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;∗&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.72777em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.6597200000000001em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;∗&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;8&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;為了避免效率太差，我們應該努力讓 page fault 在 10% 以下。&lt;/p&gt;
&lt;h3 id=&#34;demand-paging-optimuzation&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#demand-paging-optimuzation&#34;&gt;#&lt;/a&gt; Demand Paging Optimuzation&lt;/h3&gt;
&lt;p&gt;要如何增進 demand paging 呢？有以下方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;swap I/O&lt;/strong&gt; ：前面有提到到 disk 拿資料的時候並不是使用 file system，這樣太慢了，我們是在 disk 建 process image 的 copy 然後用指標標明位置再直接到該位置搬進搬出&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;不一定要清空&lt;/strong&gt;： 之後會提到 replacement ，當 process 可用的 frame 不夠時，就要把一些再記憶體的資料清掉，把位置空出來給現在在跑的區段，但如果要清掉的區段都是程式碼，其實不輕質些讓新資料覆蓋也可以，因為 code 不會在執行期間被修改&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Copy-on-Write&lt;/strong&gt;：這是指當 parent fork child 時，不會一開始就真的複製一份，而是先讓這兩個 process 共用同一份，直到其中一個 process 修改內容，才產生複製，給他們一人一份，而這樣的 fork 也稱為 vfork&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;小節&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#小節&#34;&gt;#&lt;/a&gt; 小節&lt;/h3&gt;
&lt;p&gt;本文者要介紹 demand paging 的觀念，其大部基礎都建立在之前講的 paging ，只是 demand  paging 是較省時又省空間的作法，雖然中途會遇到一些問題 (像是 page fault)，但工程師也總能找到相對應的解法，下一節會在講述 demand paging 中的其他細節，祝大家閱讀愉快&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://lu1hoao.github.io/2022/05/12/os/os-9/</guid>
            <title>Main Memory (下)</title>
            <link>https://lu1hoao.github.io/2022/05/12/os/os-9/</link>
            <category>OS</category>
            <category>Memory</category>
            <pubDate>Thu, 12 May 2022 21:23:28 +0800</pubDate>
            <description><![CDATA[ &lt;h3 id=&#34;概要&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#概要&#34;&gt;#&lt;/a&gt; 概要&lt;/h3&gt;
&lt;p&gt;本篇文主要講述 page table 和更多 paging 細節，並對整個 main maemory 做回顧，強烈建議搭配上篇一同觀看&lt;/p&gt;
&lt;h3 id=&#34;implementation-of-page-table&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#implementation-of-page-table&#34;&gt;#&lt;/a&gt; Implementation of Page Table&lt;/h3&gt;
&lt;p&gt;依照上篇提過的 page 方法，我們發現從 page 轉到 frame 需要一個 page table ，而這個 page table 就存在 memory 裡，然而問題來了，我們把資料放進 memory 得過程竟然要存取兩次 memory (一次到 page pagetable 一次到 frame) 這樣也太沒效率了吧！因此我們把 page table 放在一個類似 cache 的硬體，稱作 translation look-aside buffers (TLBs)，如果我們要找的 page 沒出現在 TLB ，這時候稱為 miss ，我們必須到主記憶體去把他的轉換資料找出來並放到 TLB 內，但有了 TLB 這個硬體可以大幅幫助我們提升效率&lt;br /&gt;
加了 TLB 的 address transfer 如下圖&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://i.imgur.com/NZVxgy8.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;h3 id=&#34;effevtive-access-time&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#effevtive-access-time&#34;&gt;#&lt;/a&gt; Effevtive Access Time&lt;/h3&gt;
&lt;p&gt;雖然字面上說增加 TLB 可以提高效率，但還是很沒有實感，那我們就來看看一個例子吧：&lt;br /&gt;
假設 TLB 的存取速度是 20ns ，記憶體的存取速度是 100ns ，有百分之八十的 page 在 TLB 當中就可以取得轉換資訊，那麼平均存取時間就是&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://i.imgur.com/XKke5l4.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;意義是有百分之八十的 page 存取一次 TLB 存取一次 memory ，百分之二十的 page ，存取一次 TLB 沒找到，又再去 page table 找 (存取第一次記憶體) 找到 fram number 後又存取第二次記憶體&lt;br /&gt;
因此若有越高的比率可以在 TLB 就找到資訊，存取速度就會越快&lt;/p&gt;
&lt;h3 id=&#34;memory-protection&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#memory-protection&#34;&gt;#&lt;/a&gt; Memory Protection&lt;/h3&gt;
&lt;p&gt;Page table 除了給予 page 對應到 frame 的位置資訊，也會有一些 bit 記錄這些 page 的其他資訊，像是 valid-invalid bit，因為同一時刻 page table 內可能會有多個 process 的資訊，要避免存取到不是自己的 page ，又或者紀錄這個 page 是否被更動過。對於某些共用部分 code 的 process 而言，我們把這些 shared code 稱為 reentrant，含有這些 code 的 page 可能就會常駐在 TLB 中，一般而言，每次 context switch ，TLB 和 page table 也要被更新&lt;/p&gt;
&lt;h3 id=&#34;structure-of-page-table&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#structure-of-page-table&#34;&gt;#&lt;/a&gt; Structure of page table&lt;/h3&gt;
&lt;p&gt;前面提過 page table 的大小和 page size 有關，假設今天有個 process 的資訊量是 2 的 32 次方，而 page size 是 4KB (2 的 12 次方)，所以這個 process 會用掉 1M ( 2 的 20 次方 ) 個 page，換句話說會有 1M 個 page 地址，假設每個地址需要 4 byte 空間，1M 個地址就會佔去 4M ，佔據記憶體 4M 的空間實在太大了，更何況我們不一定會真正利用到 page table 中的每項資訊，因此如何使放在記憶體當中的資訊不要那麼多，就發展出了以下三種作法&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Hierarchical Paging&lt;/li&gt;
&lt;li&gt;Hashed Page Tables&lt;/li&gt;
&lt;li&gt;Inverted Page Tables&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其中，Hierarchical Paging 又被稱為 multi-level paging 或 Two-level paging 或 forward-mapped paging ，是實務上最常見的方法&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Hierarchical Paging&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;是把 page table 在做分割，假設現在圖書館有 1000 本書，我們分成 100 個書架，每個書架有 10 本書，要找一本書的時候就先看他在哪一個書架再去該書架找 (這是原本的 page) 現在又把這 100 個書架分成 10 區，每區有 10 個書架，要找一本書的時候先看他在哪一區，再看他在該區的哪一個書架，最後再到該書架的 10 本書中去找，後者就是 Two-level paging&lt;/p&gt;
&lt;p&gt;原本的 logical address 包含兩個部分，一個是 page number ，一個是 offset ，page number 表示該 page 在 page table 的 index，現在我們把 page number 切成兩個部分，一個表示他對應到哪一個 page table  (又稱 outer page)，一個表示他在該 page table 中的 index (又稱 inner page)。&lt;/p&gt;
&lt;p&gt;我們把圖書館的例子用圖片說明，單純的 page 收到以下訊號&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://i.imgur.com/kb8lRiZ.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;代表第 83 個書架中的第六本書，而這個圖書館必須在門口張貼一張表，表上有 100 個書架的位置&lt;/p&gt;
&lt;p&gt;two level paging 收到這樣的訊號則會做以下解讀&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://i.imgur.com/sglq3Z8.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;代表第 8 區、第 3 個書架、第 6 本書，而這個圖書館必須張貼一張表，表上有 10 個區域的位置，每個區域入口處也要有屬於該區 10 個書架的位置。&lt;/p&gt;
&lt;p&gt;對記憶體而言 (相當於對圖書館而言) 他需要紀錄的東西從 100 個書架的位址縮小成 10 個區域的位置，減少了很大的負擔。對 CPU 而言 (相當於要找書的人而言)，也不需要修改自己表示資訊的方式 (address 長度不變)，只要換個角度看待資訊就好了。在主記憶體當中只需要存放一個 page table (即圖書館門口的區域位置表)，對每一個 page table 而言，專屬於他們的第二層 page table (相當於各區域門口的書架位址) 放在 disk 即可，需要的時候再去拿，而拿取的技術可以使用前一篇文章提到的 memory image&lt;br /&gt;
 在 two level paging 中會收到兩個位址資訊，其中第一個位址資訊又會成為第二個位址資訊的查詢基礎，有點指來指去的概念。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Hashed Page Table&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;顧名思義就是利用雜湊函數對資料作處理，在主記憶體當中存放雜湊表，假設收到以下資訊&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://i.imgur.com/mPu26jr.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;我們先把 83 mod 7 ，發現餘 6 ，於是找到第六項在去做更進一步處理，看是利用 linklist 或是第二個 page table 還是怎樣都可以，但主記憶體當中只需要存取一個有 7 個項目的雜湊表 (餘數從 0 到 6)，在做雜湊表的時候我們都常會假設資訊是 sparse 的，意思是平均分散的，這樣可以避免 link list 過長。&lt;/p&gt;
&lt;h3 id=&#34;intel-32&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#intel-32&#34;&gt;#&lt;/a&gt; Intel 32&lt;/h3&gt;
&lt;p&gt;在實務上也不是只有利用一種方法做 virtual address 的轉換， Intel 32 就是結合 segmentation 和 paging 的例子，這樣可以結合兩者的優點， segmentation 比較符合人類的分法， 把同樣性質的資料放在一起，paging 則是可以避免 external fragmentation ，所以在 Intel 32 是這樣做的，在 logical address 階段，會得到 segment 資訊和 offset，segmet 資訊稱為  selector，是一個指標，然後在到 descriptor table 中找到他的 base 和 limit ，把 offset 加上 base 之後得到 linear address ，linear assdess 再透過兩次 paging 得到 physical address ，以圖片說明下&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://i.imgur.com/lOacBea.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;以上就是記憶體的小小小科普，祝大家閱讀愉快&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://lu1hoao.github.io/2022/05/11/os/os-8/</guid>
            <title>Main Memory (上)</title>
            <link>https://lu1hoao.github.io/2022/05/11/os/os-8/</link>
            <category>OS</category>
            <category>Memory</category>
            <pubDate>Wed, 11 May 2022 21:23:28 +0800</pubDate>
            <description><![CDATA[ &lt;h3 id=&#34;概要&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#概要&#34;&gt;#&lt;/a&gt; 概要&lt;/h3&gt;
&lt;p&gt;本文主要講述 Memory 的管理，從背景、 Contiguous Memory Allocation 講到 Segmentation、Paging，對 multiprogramming 的系統而言，記憶體管理很重要，他也會大大影響到執行速度&lt;/p&gt;
&lt;h3 id=&#34;背景&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#背景&#34;&gt;#&lt;/a&gt; 背景&lt;/h3&gt;
&lt;p&gt;我們寫的程式要被執行，必須先被載入到主記憶體當中，CPU 再從 Memory (含 cache) 或 register 去讀取資訊並執行，然而 CPU 看到的這些指令與變數位址並不代表他們真正在記憶體當中的位置，舉例來說，CPU 看到「請執行第十行的指令」這個敘述不表示第十行指令的位址真的在記憶體當中的第十行， 10 這個數字是相對位址，相當於這個程式的第十行，而這個程式的第十行被儲存在記憶體的哪個位置呢？我們需要透過 Memory Management Unit ( MMU ) 搭配 Translation lookaside buffer 來做轉換 ( TLB )，示意圖如下&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://i.imgur.com/niAzWW5.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Memory Management Unit&lt;/strong&gt; (MMU) : 把虛擬地址轉成真實地址的硬體&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Translation Lookaside Buffer&lt;/strong&gt; (TLB): 告訴 MMU 怎麼轉的表 ( a cache for the MMU&#39;s virtual-to-physical translation table )&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;base-and-limit-registers&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#base-and-limit-registers&#34;&gt;#&lt;/a&gt; Base and Limit Registers&lt;/h3&gt;
&lt;p&gt;我們先來看一下簡單的 MMU 轉換例子，假設系統會提供一個 base register ，表示這個程式開端所在的記憶體位址 (真實位址)，那這個程式的每一個指令或變數的真實位址就是他們的相對位址加上這個 base register，這個 base register 又稱為 relocation register，所以可以得到&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;virtual address + relocation register = physical address&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;今天執行程式的 relocation register 和明天執行程式的 relocation register 可能不一樣，因為記憶體空間配置的情形有所差異，但如果程式碼沒有修改，今天和明天的 virtual address 應該是相同的&lt;br /&gt;
大部分時候， complier 會提供 limit register 表示這個程式最大可存取的空間，供系統去做檢查，如果發現這個程式有某個指令或變數位址超過了 relocation register + limit register 的值，我們就可以發覺這個程式應該是有誤的，他會侵犯到別人的空間，以圖片說明：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://i.imgur.com/jn5GWNf.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;那我們是甚麼時候得到相對位址甚麼時候得到絕對位址的呢？&lt;br /&gt;
這時候就要先來看看程式從寫好到被執行經過了哪些步驟&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;complier&lt;/li&gt;
&lt;li&gt;linker &amp;amp; loader&lt;/li&gt;
&lt;li&gt;execution&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在上面三步中我們是在最後一部才得到真實位址，前面兩部都只是得到相對位址，這裡也要注意所謂的程式起始位置，對不同型態資料來說就會有不同的基準值喔，以下方程式碼說明&lt;/p&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption data-lang=&#34;c&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;JUMP X&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;ADD #&lt;span class=&#34;token number&#34;&gt;4&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;LOAD Y&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;X 是指第幾行程式碼， Y 則是一個變數，他們在不同的 segment&lt;br /&gt;
 基準位址就不一樣，在 segmentation 中會有更進一步的說明&lt;/p&gt;
&lt;h3 id=&#34;swapping&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#swapping&#34;&gt;#&lt;/a&gt; Swapping&lt;/h3&gt;
&lt;p&gt;swapping 中文是交換的意思，在這裡是指當記憶體位置不足又想跑一個大程式時，我們會把優先權比較低的程式踢去 disk (Backing store) ，讓比較高優先權體積又比較大的程式先跑，這種情況其實很少發生，因為這是下下策，工程師應概要設法用比較好的記憶體管理演算法讓空間使用率最佳化。但不幸出現這種事時，我們會把低優先權程式在記憶體中的狀態原封不動地搬到 disk ，稱為 memory image ，再次啟動低優先權 process 時就不需要再透過檔案系統開啟&lt;/p&gt;
&lt;h3 id=&#34;contiguous-allocation&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#contiguous-allocation&#34;&gt;#&lt;/a&gt; Contiguous Allocation&lt;/h3&gt;
&lt;p&gt;現在我們終於可以來看一下記憶體是如何被使用的了，一般來說記憶體被分為兩大塊 (two partitions) 一塊給 OS ，一塊給我們要跑的程式，在 multiprogramming 系統中，又把放置 user process 的記憶體切成多塊，切法又可分為以下兩種：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Fixed Partition&lt;/strong&gt;&lt;br /&gt;
 顧名思義，這裡的記憶體被切成等大的片段，每個片段放置一個 process，假設現在記憶體當中有 3 個 process ，那我們就說現在 degree 是 3，但是切成等大的片段會造成空間利用率不高，對於那些所需空間小於一個片段的 process 來說，我們多給的片段他也用不到，這種被浪費掉的空間稱為 &lt;strong&gt;Interal Fragmentation&lt;/strong&gt;，對於大小超過一個片段的 process 他也放不進去無法被執行，因此這個做法還有很多變形，像是執行一個大 process 時，不需要把整個 process 都放到記憶體，只需要放正在執行的片段就可以了&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Variable-Partition&lt;/strong&gt;&lt;br /&gt;
Variable-Partition 就是把記憶體切成大小不一的片段，以符合每個 process 不同的空間需求&lt;br /&gt;
&lt;strong&gt; (1) Buddy&#39;s System：&lt;/strong&gt;&lt;br /&gt;
Buddy&#39;s system 是指讓每塊記憶體片段都是 2 的指數次方大小，比如 2、4、8、16、64，假設今天來了一個 35 大小的 process 他就選擇 64 這個記憶體片段，但假如今天 64 大小的都用完了怎麼辦呢？就選擇 128 大小的，但把 128 切成兩塊 64，一塊給 35 ，剩下的一塊就待命&lt;br /&gt;
&lt;strong&gt; (2) 一般的 variable partition ：&lt;/strong&gt;&lt;br /&gt;
就是依照 process 大小給與剛好空的空間&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;當 process 離開記憶體後他原本佔據的空間就會空出來，稱為 &lt;strong&gt;hole&lt;/strong&gt; (也可以說，沒被 process 佔據的空間都視為 hole)，當新的 process 要進來記憶體時，就從這些 hole 挑選一個適合大小給 process，怎麼挑呢？又可以分為以下幾種&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;First-fit&lt;/strong&gt;：找到第一個是大小大於或等於 proess 的 hole 就結束&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Best-fit&lt;/strong&gt;：找到大小大於或等於 process 的 hole，且這個 hole 是所有可供 process 運用的 hole 當中最小的&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Next-fit&lt;/strong&gt;：從上一個找到的 hole 作為起點，當找到第一個大小大於或等於 process 的 hole 之後就結束&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以圖片說明，假設灰色是以被占據的記憶體空間，白色是 hole，現在來了一個需要 16 大小的 proess，那根據不同的選法就會有不一樣的結果&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://i.imgur.com/BxorVjG.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;一般來說， first-fit 會讓上面的記憶體更常被選到，經常使用意味著更容易壞掉， best-fit 則需要全部搜尋一遍有點浪費時間，next-fit 算是比較折衷的方法但是也可能會選到 worst fit (適合 process 的 hole 中，最大的那一個)&lt;/p&gt;
&lt;p&gt;如果今天有一個大小為 3 的洞，和一個大小為 5 的洞，來了一個大小為 7 的 process 要怎麼辦呢？ 如果系統沒辦法透過調整記憶體中 process 的位置來解決這個問題，我們就稱這兩個洞是 &lt;strong&gt;External Fragmentation&lt;/strong&gt;，雖然是可運用的空間卻無法真正被利用。為了解決這個問題，我們需要 &lt;strong&gt;Compaction&lt;/strong&gt; ，調整記憶體中 process 的位置，讓這兩個洞合併成一個大洞供 process 使用，調整 process 位置就需要最一開始提到的 relocation code 才有辦法&lt;/p&gt;
&lt;h3 id=&#34;segmentation&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#segmentation&#34;&gt;#&lt;/a&gt; Segmentation&lt;/h3&gt;
&lt;p&gt;我們的程式是由不同的 segment 組成的，比如變數存在 data segment，程式碼存在 code segment，當我們要找出這些變數或程式碼的真實位置時，就需要取他們的虛擬位置加上 segment 資訊。&lt;br /&gt;
一般來說，logical address (virtual address) 是由兩個數字組成，一個表示他在哪一個 segment (他們的型態) ，通常為 segment-table base register (STBR，指向該 segment table 在記憶體中的位址) 和他們的 offset (位移，相當於對該 segment 起點的位移)，我們透過 segment table 可以得到 base 和 limit 資訊，進而得到 physical address ，以圖片說明&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://i.imgur.com/6BJyXtk.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;h3 id=&#34;paging&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#paging&#34;&gt;#&lt;/a&gt; Paging&lt;/h3&gt;
&lt;p&gt;Paging ，是把 process 分成大小相同的區塊稱為 page (和 segment 不同喔， 每塊 segment 大小可能不同)，然後在真實記憶體當中，我們也切成大小相同的好幾塊，稱為 frame ，一塊 frame 的體積和一塊 page 的體積大小相同，透過 page table ，把 page 資訊放到 frame 當中。這樣的做法可以避免 external fragmentation，但依然會有 internal fragmentation 以下方簡圖說明&lt;br /&gt;
 CPU 得到的 logical address (virtual address)，包含兩個數字，一個是 &lt;strong&gt;virtual page number&lt;/strong&gt; (VPN)，是一個 index ，表示這個 page 在 page table 中的位置，和一個 Page offse 該資料相對於這個 page 的起始位址位移多少，在 page table 中則會記載每一個 page table 對應到真實記憶體當中的哪一個 frame&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://i.imgur.com/Zd8yrER.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;這裡要注意從 page 對應到 memory 不一定要依照 page 的次序，舉例來說第一塊 page 不一定要對應到第一塊 frame，也可以是第五塊，因為每一塊 frame 大小都相同，所以對應到哪一塊其實沒差，隱含著一個重要訊息，&lt;strong&gt;在真實記憶體當中，一個 process 存放的空間可以是不連續的&lt;/strong&gt;，事實上 page 分類在 disk 就已經完成，後面會更詳細解說。 我們用下面例子說明空間使用情況&lt;br /&gt;
假設一個 page 是 2048 bytes，有一個 72766 bytes 的 process ，這樣他需要 36 個 pages ，但最後一個 page 沒有裝滿，會有 962 bytes 的 internal fragmentation&lt;br /&gt;
 如果一個 page 容量越大，就可能會造成越多 internal fragmentation ，如果單一 page 容量很小又會造成 page table 很大，因為他要存放這些 page 的位址，不過依電腦趨勢而言， page 的尺寸是越做越大&lt;/p&gt;
&lt;p&gt;原本想要一篇打完的，但內容好多，剩下的留到下篇，祝大家閱讀愉快&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://lu1hoao.github.io/2022/05/02/os/os-7/</guid>
            <title>Deadlocks(下)</title>
            <link>https://lu1hoao.github.io/2022/05/02/os/os-7/</link>
            <category>OS</category>
            <category>Deadlock</category>
            <pubDate>Mon, 02 May 2022 21:23:28 +0800</pubDate>
            <description><![CDATA[ &lt;h3 id=&#34;概要&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#概要&#34;&gt;#&lt;/a&gt; 概要&lt;/h3&gt;
&lt;p&gt;本篇文主要講述 deadlock prevention 和 deadlock avoidence ，前者是在開始執行之前就先預防，避免產生 deadlock ，後者則是邊執行邊看，確保走的每一步都會讓系統維持在安全狀態，不過這兩者的核心概念都是避免達到四項條件&lt;/p&gt;
&lt;h3 id=&#34;deadlock-prevention&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#deadlock-prevention&#34;&gt;#&lt;/a&gt; Deadlock prevention&lt;/h3&gt;
&lt;p&gt;我們依照四項條件逐一攻破&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Mutex Exclusion&lt;/strong&gt; 既然是互斥，一次只能允許一個 process 存取一項資源，那我們就盡考能讓資源共享化，只要不是明確規定說不可以分享的，我們都讓他分享&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Hold and Wait&lt;/strong&gt; 這個原本是說我拿到一項資源了但是還沒湊齊所有我需要的，所以我正等待著，打破這條件的方法就是規定一定要一次拿齊所有東西，不可以先拿著某些東西然後等待，要就要全拿不然就兩手空空&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;No preemption&lt;/strong&gt; 這個是指該 process 除非是自願放棄否則無法被搶先，解決該問題的方法，就是有一個 process 當自願者，當她所需的資源一直要不到時，他就自願放棄釋出他已經拿到的資源，讓系統重新分配&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Circular wait&lt;/strong&gt; ，這個是指互相等待的情況，解決這個問題的方法就是把資源編號，假設 process a 需要 1 3 資源， process b 需要 3 4 資源 process c 需要 1 4 資源，原本可能會 a 拿到 1，b 拿到  3 ，c 拿到 4 ，進而互相等待，但如果規定一定要從自己所需資源中編號小的開始拿取那麼 c 拿不到 1 ，他也無法拿 4 ，系統就不會形成 circular wait&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下來我們就來看看這些方法是如何解決 dining philiphers deadlock，下面是最一開始的程式碼&lt;/p&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption data-lang=&#34;c&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;do&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token function&#34;&gt;wait&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;chopstick&lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt;i&lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token function&#34;&gt;wait&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;chopstick&lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;i&lt;span class=&#34;token operator&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;%&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;     &lt;span class=&#34;token comment&#34;&gt;//eat&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token function&#34;&gt;signal&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;chopstick&lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt;i&lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;6&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token function&#34;&gt;signal&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;chopstick&lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt;i&lt;span class=&#34;token operator&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;%&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;7&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;   &lt;span class=&#34;token comment&#34;&gt;//think&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;8&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;span class=&#34;token keyword&#34;&gt;while&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;true&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;如果所有哲學家都先拿起自己左邊的筷子，他們永遠拿不到自己右邊的筷子，造成 deadlock。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用方法一 mutex：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我們設定一個仲裁器規定現在輪到哪個哲學家吃東西，只有在輪到他時他才可以吃，這樣一次只有一個哲學家可以吃東西，但保證大家都吃得到&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用方法 2 打破 hold and wait&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;我沒辦法一次拿兩支筷子那我就不拿了，乍看之下這個方法有解，他也確實不會造成 deadlock，但可能會引發新的問題，稱為 &lt;strong&gt;livelock&lt;/strong&gt; ，想像現在這群哲學家一個口令一個動作的全部同時舉起左邊筷子，發現無法拿起右邊，於是又全部同時一起放下，接著又全部同時憶起舉起右邊，發現無法舉起左邊，又全部同時一起放下，這樣來來回回雖然沒有 deadlock ，卻依然吃不到東西。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用方法 3 打破 No preemption：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;先把一位哲學家移出餐桌，剩下的人就可以順利執行，之後再請那位先犧牲小我的哲學家回來，所以方法 3 是行得通的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用方法 4 按照次序拿取資源：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;這樣第 n 位哲學家就沒辦法順利的吃飯，剩下的幾個人可以，那這個 deadlock 就順利被解開了&lt;/p&gt;
&lt;h3 id=&#34;deadlock-avoidence&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#deadlock-avoidence&#34;&gt;#&lt;/a&gt; Deadlock Avoidence&lt;/h3&gt;
&lt;p&gt;是先預防雖然有效，但會造成資源的使用率很低，有沒有甚麼方法可以邊做邊看呢？那就是 &lt;strong&gt;Banker&#39;s  Algorithm&lt;/strong&gt;，把作業系統想成是銀行， process 是要借貸的客戶，資源是電腦的資產，銀行應該要優先把資源借給那些&lt;strong&gt;要求沒超過自己負荷量的客戶&lt;/strong&gt;，比如總資產 2000 元，一個人想借 200 元，一個人想借 3000 元，先借兩百元的自己才不會破產，我們用表格來說明&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;已拿到&lt;/th&gt;
&lt;th&gt;所有需要的&lt;/th&gt;
&lt;th&gt;還需要的&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;P1&lt;/td&gt;
&lt;td&gt;0014&lt;/td&gt;
&lt;td&gt;0656&lt;/td&gt;
&lt;td&gt;0642&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P2&lt;/td&gt;
&lt;td&gt;1432&lt;/td&gt;
&lt;td&gt;1942&lt;/td&gt;
&lt;td&gt;0510&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P3&lt;/td&gt;
&lt;td&gt;1354&lt;/td&gt;
&lt;td&gt;1356&lt;/td&gt;
&lt;td&gt;0002&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P4&lt;/td&gt;
&lt;td&gt;1000&lt;/td&gt;
&lt;td&gt;1750&lt;/td&gt;
&lt;td&gt;0750&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;數字並不是四位數而是代表這些 process 需要四種資源，以及他們所需該資源的個數，假設電腦現在可負擔 1520 ，那他應該要先把資源給 P2， 因為 P1 他給不起，給完 P2 後他就可以把 P2 的資源收回來 (P2 已經做完了)，現在電腦資源變成 2952 可以給 P3 ，再把 P3 的資源收回來... 依此類推，如果我們可以找到一個執行順序讓每一個 process 都可以被順利執行，那我們就會稱為這是一個安全狀態，我們要確保系統永遠都會在安全狀態，走了住一步之後下一步還有路可走才不會 deadlock ，大概就是這個意思。&lt;/p&gt;
&lt;p&gt;以上就是 deadlock 的預防和避免，祝大家閱讀愉快&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://lu1hoao.github.io/2022/05/02/os/os-6/</guid>
            <title>Deadlocks(上)</title>
            <link>https://lu1hoao.github.io/2022/05/02/os/os-6/</link>
            <category>OS</category>
            <category>Deadlock</category>
            <pubDate>Mon, 02 May 2022 20:23:28 +0800</pubDate>
            <description><![CDATA[ &lt;h3 id=&#34;概要&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#概要&#34;&gt;#&lt;/a&gt; 概要&lt;/h3&gt;
&lt;p&gt;Deadlocks 是指多個 process 在執行時因為達到某些條件，使得所有 process 都無法運作只能待在原地發呆的情況，本文主要講述達成 Deadlock 的條件 (Coffman&#39;s conditions)、Handling Deadlocks、下篇則會講述 deadlock prevention (在開始執行之前就先確保 deadlock 不會發生，預防的概念) 和 deadlock avoidence&lt;/p&gt;
&lt;h3 id=&#34;resource-allocation-graph&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#resource-allocation-graph&#34;&gt;#&lt;/a&gt; Resource-Allocation Graph&lt;/h3&gt;
&lt;p&gt;在開始之前我們先來看一 下電腦資分配圖，會有助於我們對 deadlock 條件的了解，假設電腦有不同的資源型態 R1、R2、R3 ，每個型態的資源個數不一定為一，而有多個 process p1、p2、p3，每個 process 會根據自己的需求去要所需的資源，假設 p1 request R3 (p3 需要資源 3)，我們就畫一個箭頭從 p1 指向 R3，(箭頭方向很重要喔)，假設 R2 分給 pj (亦即 pj 需要 R2 且系統核准了那麼 R2 就分給 pj)，畫一個箭頭從 R2 指向 pj，得到下圖&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://i.imgur.com/P56ApDW.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;但要注意 R3 型態的資源不一定只有一個，所以如果現在又有一個 process 需要 R3 資源他未必要等待，這就好像是一間自助洗衣店裡面，有洗衣機 (假設 4 台) 有烘衣機 (假設 8 台) 有兌幣機 (假設 1 台) 有洗衣精販賣機 (假設 1 台)，今天來了兩個客人，他們一個要用洗衣機，一個要用烘衣機，那就各自用各自的，一切很順暢，但如果兩個人都要用兌幣機，就需要等待，我們待會會用 resource-allocation graph 來描述 circular wait&lt;/p&gt;
&lt;h3 id=&#34;deadlock-characterization&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#deadlock-characterization&#34;&gt;#&lt;/a&gt; Deadlock Characterization&lt;/h3&gt;
&lt;p&gt;deadlock characterization ，又稱為 Coffman&#39;s conditions，是只會造成 deadlock 的條件，以下四個條件&lt;strong&gt;同時&lt;/strong&gt;發生時就會產生 deadlock&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Mutual execlusion&lt;/strong&gt; 互斥，當一次只有一個 process 可以使用該資源物件時 (一台洗衣機一次只能給一個使用者使用)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Hold and wait&lt;/strong&gt; 某 process　需要兩個以上資源才能運作，他拿了其中一個，卻在等另一個，沒等到他也不能動（就像某人去自助洗衣店，還沒換好零錢就先把衣服丟到洗衣機裡佔位，但兌幣機前大排長龍，他沒兌到幣也不能洗）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;No preemption&lt;/strong&gt; 這個 process 是不能被搶先的，就算他握有很珍貴的資源卻執行很慢，後面的人還是不能把它的資源搶過來做，除非他自願放棄&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Circular wait&lt;/strong&gt; 循環等待， A 等 B，B 等 C，C 等 A，大家等來等去甚麼事都不能做，把 Circular wait 的 resource allocation grapg 畫出來會發現他們繞成一個圈，但不代表繞成一個圈就一定會 dwadlock 喔，如果該資源只有一件時才會 deadlock，兩者並非若且為若的關係&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;這張圖片以長方形表示資源 (不同顏色表示不同型態)，把 recource allocation 畫出來發現可以找到兩個圈，這張會造成 deadlock，因為 p1 在等 p2 ， p2 在等 p3， p3 在等 p1 或 p2&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://i.imgur.com/qWdJvjA.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;然而下面這個情況卻不一定會產生 deadlock，因為 p3 不一定要等待 p1，他也可以等 p4&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://i.imgur.com/NnFUWlX.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;h3 id=&#34;methods-for-handling-deadlocks&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#methods-for-handling-deadlocks&#34;&gt;#&lt;/a&gt; Methods for Handling Deadlocks&lt;/h3&gt;
&lt;p&gt;既然我們剛剛已經介紹 deadlock 的行程條件，接下來就來看看電腦是如何處理 deadlock 的&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;確保 deadlock 永遠不會發生，使用 deadlock prevention (事先預防) 和 deadlock avoidence (過程中避免)&lt;/li&gt;
&lt;li&gt;如果沒辦法做到上面，真的執行中遇到 deadlock 了，那就只好選一個受害者 process ，把他強制結束，釋放他原本持有的資源再重新分配&lt;/li&gt;
&lt;li&gt;最後一種就是都不要管，我作業系統不負責處理 deadlock，其實這是大多數作業系統的態度，認為避免 deadlock 是使用者的義務，然而這麼做不代表 deadlock 不重要，在網路上 deadlock 的避免就是很重要的技術&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文主要介紹了達成 deadlock 的四項條件，並從 resource-allocation 圖中辨別是否會造成 deadlock ，下篇會講解 deadlock prevention 和 deadlock avoidence ，主要就是避免系統達到四項條件，祝大家閱讀愉快&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://lu1hoao.github.io/2022/04/29/os/os-5/</guid>
            <title>Synchronization Examples</title>
            <link>https://lu1hoao.github.io/2022/04/29/os/os-5/</link>
            <category>OS</category>
            <category>Synchronization</category>
            <pubDate>Fri, 29 Apr 2022 20:23:28 +0800</pubDate>
            <description><![CDATA[ &lt;h3 id=&#34;概要&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#概要&#34;&gt;#&lt;/a&gt; 概要&lt;/h3&gt;
&lt;p&gt;上篇文章簡單介紹了 Synchronization 的解法，現在我們要來看更多會遇到同步問題的情況 (上次只簡單講了 Bounded-Buffer Problem)，這些經典問題現在都已經變成一種測試，當我們提出新的 Synchronization 方法時，就要拿這些經典問題去測試，看看我們的方法是否比前人的好。同時也會說明一些作業系統是如何支援這些 Synchronization 演算法&lt;/p&gt;
&lt;h3 id=&#34;bounded-buffer-problem&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#bounded-buffer-problem&#34;&gt;#&lt;/a&gt; Bounded-Buffer Problem&lt;/h3&gt;
&lt;p&gt;這個問題就是之前說的有 consumer 和 producer 的問題，我們在這裡把他的演算法寫得更詳細，首先會有共用變數 mutex (初值為 1)、 full ( 初值為 0 ，表示未滿)、 empty (初值為 n , 表示可以放 n 件物品)，對 producer 而言，有以下程式碼&lt;/p&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption data-lang=&#34;c&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;do&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token function&#34;&gt;wait&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;empty&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;token comment&#34;&gt;/*n-1*/&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token function&#34;&gt;wait&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;mutex&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  critical sextion&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token function&#34;&gt;signal&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;mutex&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;6&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token function&#34;&gt;signal&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;full&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;token comment&#34;&gt;/*0+1*/&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;7&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;span class=&#34;token keyword&#34;&gt;while&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;true&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;對 consumer 而言有以下程式碼&lt;/p&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption data-lang=&#34;c&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;do&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token function&#34;&gt;wait&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;full&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token function&#34;&gt;wait&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;mutex&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token function&#34;&gt;signal&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;mutex&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token function&#34;&gt;signal&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;empty&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;6&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;span class=&#34;token keyword&#34;&gt;while&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;true&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;要特別注意 empty 和 full 的位置，producer 是要進到 empty 的空間放東西，所以先把 empty 的值扣一， consumer 是到滿的地方拿東西，所以把 full 扣一。 mutex 則是要確保沒有別人在 critical section。&lt;/p&gt;
&lt;h3 id=&#34;readers-writers-problem&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#readers-writers-problem&#34;&gt;#&lt;/a&gt; Readers-Writers Problem&lt;/h3&gt;
&lt;p&gt;剛剛的 Bounded-Buffer Problem 是在描述兩個 process 都可以改值的狀況，還有一種情況是有多個 writer 和多個 reader process 的情況，同一時間可以有多個 reader ，但 writer 只能單獨存在 (writer 不能和 reader 共存也不能和其他 writer 共存)，這種問題通常有兩種解法&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;First&lt;/strong&gt; 除非 writer 被准許可以寫不然 reader 可以很自由的閱讀&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Second&lt;/strong&gt; 當 writer 想寫就寫&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;這兩種都是利用 Priority 排序，所以都會有 Starvation 的問題，第一種是 writer 會餓死，第二種是 reader 會餓死，我們來更仔細的看第一種解法，所有 process 會共用以下變數方便 mutex：&lt;strong&gt;rw_mutex (預設為 1)， mutex ( 預設為 1)、read_count (預設為 0)&lt;/strong&gt;，為甚麼要計算讀者的人數呢？因為當讀者為 0 時 (read_count=0) 就可以告訴 writer 來寫了 (要沒人看的時候才能寫，因為我們在第一種)，先來看看 writer 的程式碼&lt;/p&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption data-lang=&#34;c&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;do&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token function&#34;&gt;wait&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;rw_mutex&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    &lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token comment&#34;&gt;/*writing is performed*/&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    &lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;6&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token function&#34;&gt;signal&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;rw_mutex&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;7&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;span class=&#34;token keyword&#34;&gt;while&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;true&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;rw_mutex 是一個確定沒有其他 writer 在撰寫，也沒有 reader 在閱讀的機制 (for writer &amp;amp; reader) ，接下來看一下 reader 的程式碼&lt;/p&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption data-lang=&#34;c&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;do&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token function&#34;&gt;wait&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;mutex&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  read_count&lt;span class=&#34;token operator&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token keyword&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;read_count&lt;span class=&#34;token operator&#34;&gt;==&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    &lt;span class=&#34;token function&#34;&gt;wait&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;rw_mutex&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;6&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token function&#34;&gt;signal&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;mutex&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;7&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;8&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token comment&#34;&gt;/* 開始閱讀 */&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;9&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;10&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token function&#34;&gt;wait&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;mutex&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;11&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  read_count&lt;span class=&#34;token operator&#34;&gt;--&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;12&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token keyword&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;read_count&lt;span class=&#34;token operator&#34;&gt;==&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;13&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    &lt;span class=&#34;token function&#34;&gt;signal&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;rw_mutex&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;14&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token function&#34;&gt;signal&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;mutex&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;15&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;span class=&#34;token keyword&#34;&gt;while&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;true&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;為甚麼在進入時要先確認 mutex 呢？不是可以同時讀嗎？這是因為要修改 read_count 的數目，修改共同變數本身就是一個需要進入 critical section 的情況，所以需要有一個 mutex 機制確保一次只有一個 reader process 再更改 read_count ，當讀者是第一個讀者是他要確保已經有都興可以讀了，所以要看一下 rw_mutex 的狀態，最後一個離開的讀者要告訴 writer 好了你可以來寫了。&lt;/p&gt;
&lt;h3 id=&#34;dining-philosophers-problem&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#dining-philosophers-problem&#34;&gt;#&lt;/a&gt; Dining-Philosophers Problem&lt;/h3&gt;
&lt;p&gt;有個命題稱為飢餓的哲學家，一群哲學家坐在一圓桌，不是在思考就是在吃東西，然而這群哲學家使用筷子吃飯，他們左手邊的筷子和左邊的人共用，右手邊的筷子和右邊的人共用，就像下面的圖一樣，黃色的是桌子，藍色是筷子，總共有四位哲學家，共用四支筷子，那哲學家要如何吃飯呢？&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://i.imgur.com/Rgw1Dtg.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;我們先來看一個&lt;strong&gt;不太好&lt;/strong&gt;的解法，共用變數有 chopstick [4] (初值為 1 )&lt;/p&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption data-lang=&#34;c&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;do&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token function&#34;&gt;wait&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;chopstick&lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt;i&lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token function&#34;&gt;wait&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;chopstick&lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;i&lt;span class=&#34;token operator&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;%&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;     &lt;span class=&#34;token comment&#34;&gt;//eat&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token function&#34;&gt;signal&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;chopstick&lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt;i&lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;6&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token function&#34;&gt;signal&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;chopstick&lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt;i&lt;span class=&#34;token operator&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;%&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;7&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;   &lt;span class=&#34;token comment&#34;&gt;//think&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;8&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;span class=&#34;token keyword&#34;&gt;while&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;true&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;若全部哲學家同時舉起他們的同一手，那他們永遠無法拿到另外一手的筷子最後就卡死，所以我們修改一下&lt;/p&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption data-lang=&#34;c&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;monitor DiningPhilosopheres&lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token keyword&#34;&gt;enum&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;THINKING&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt;HUNGRY&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt;EATING&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt; state&lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  condition self&lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;pickup&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token keyword&#34;&gt;int&lt;/span&gt; i&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;6&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    state&lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt;i&lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;HUNGRY&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;7&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    &lt;span class=&#34;token function&#34;&gt;test&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;i&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;8&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    &lt;span class=&#34;token keyword&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;state&lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt;i&lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;!=&lt;/span&gt;EATING&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt; self&lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt;i&lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;wait&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;9&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;10&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;putdown&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token keyword&#34;&gt;int&lt;/span&gt; i&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;11&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    state&lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt;i&lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;THINKING&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;12&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    &lt;span class=&#34;token function&#34;&gt;test&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;i&lt;span class=&#34;token operator&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;%&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;13&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    &lt;span class=&#34;token function&#34;&gt;test&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;i&lt;span class=&#34;token operator&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;%&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;14&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;15&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;test&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token keyword&#34;&gt;int&lt;/span&gt; i&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;16&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    &lt;span class=&#34;token keyword&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;state&lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;i&lt;span class=&#34;token operator&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;%&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;!=&lt;/span&gt;EATING&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;state&lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;i&lt;span class=&#34;token operator&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;%&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;!=&lt;/span&gt;EATING&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;state&lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt;i&lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;==&lt;/span&gt;HUNGRY&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;17&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;      state&lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt;i&lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;EATING&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;18&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;      self&lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt;i&lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token function&#34;&gt;signal&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;19&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    &lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;20&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;21&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token function&#34;&gt;initialization_code&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;22&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    &lt;span class=&#34;token keyword&#34;&gt;for&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token keyword&#34;&gt;int&lt;/span&gt; i&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;i&lt;span class=&#34;token operator&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;i&lt;span class=&#34;token operator&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;23&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;      state&lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt;i&lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;THINKING&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;24&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;25&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;哲學家甚麼時候可以舉起筷子呢？他餓的時候，光餓的時候還不行，他必須先檢查左邊右邊有沒有在吃，如果沒有他就可以把狀態改成 EATING，吃飽之後要放下筷子把狀態改成 THINKING 然後換自己左邊和右邊的，這樣的架構雖然不會造成 deadlock (剛剛說的卡死) 但可能會有人餓死，若某個哲學家一直吃都不放筷子的話他左右的人就很可憐&lt;/p&gt;
&lt;h3 id=&#34;os-support&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#os-support&#34;&gt;#&lt;/a&gt; OS support&lt;/h3&gt;
&lt;p&gt;大部分的作業系統都有提供一些支原來實現 synchronization ，我們來看一些例子&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;spin-lock&lt;/strong&gt; 最早是在 Solaris 這個作業系統被提出，運用 adaptive mutexes 的觀念，意思是說，如果 lock 被一個 thread 持有，且這個 thread 正在使用 CPU 那我就等待這個 lock，如果持有 lock 的 thread 沒有在被執行，那我就先去睡了吧別等了，在 Windows 上，持有 spinlock 的 thread 不會被 preemptive&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;readers-writers locks&lt;/strong&gt; 用在 readers writers problem ，在 Solaries 中會使用 turnstiles 來安排想要獲取 lock 的 thread&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;dispatch objects&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;非-os-support&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#非-os-support&#34;&gt;#&lt;/a&gt; 非 OS support&lt;/h3&gt;
&lt;p&gt;也有一些方法是藉由其他東西來實現 synchronization，像是 transactional memory (由 memory 確保某些資料是 automically 的) 或是 open MP (展開聚集)、Functional Programming Languages&lt;/p&gt;
&lt;p&gt;以上就是 Synchronization 的更多實例，祝大家閱讀愉快&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://lu1hoao.github.io/2022/04/28/os/os-4/</guid>
            <title>Synchronization Tools (下)</title>
            <link>https://lu1hoao.github.io/2022/04/28/os/os-4/</link>
            <category>OS</category>
            <category>Synchronization</category>
            <pubDate>Thu, 28 Apr 2022 20:23:28 +0800</pubDate>
            <description><![CDATA[ &lt;h3 id=&#34;概要&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#概要&#34;&gt;#&lt;/a&gt; 概要&lt;/h3&gt;
&lt;p&gt;上一篇文章講述了實現同步的幾個演算法，核心觀念就是確保一次只有個 process 或 thread 在修改共同變數，但是 hardware-based solutions 比較難被撰寫高階語言的程式設計師使用，所以作業系統提供了 Mutex Locks、Semaphore、Monitors 這些工具，本文主要介紹這三種解法&lt;/p&gt;
&lt;h3 id=&#34;mutex-locks&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#mutex-locks&#34;&gt;#&lt;/a&gt; Mutex Locks&lt;/h3&gt;
&lt;p&gt;所謂的 Mutex Locks 就像是作業系統提供了一把鑰匙給所有要存去共同變數的 process ，誰搶到鑰匙誰就有權修改，修改完之後也要把鑰匙還回來，想拿鑰匙必須呼叫 acquire (), 還鑰匙必須呼叫 release ()，而這兩個函式在執行時都是不可被中斷的，結構如下&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;acquire lock&lt;/li&gt;
&lt;li&gt;critical section&lt;/li&gt;
&lt;li&gt;release lock&lt;/li&gt;
&lt;li&gt;remainder section&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以程式碼來看&lt;/p&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption data-lang=&#34;c&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token function&#34;&gt;acquire&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt; &lt;span class=&#34;token keyword&#34;&gt;while&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;!&lt;/span&gt;available&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt; available&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;false&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token function&#34;&gt;release&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;6&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt; available&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;true&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;7&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;然而這樣會造成 &lt;strong&gt;busy waiting&lt;/strong&gt;，在 &lt;code&gt;while(!available);&lt;/code&gt;  中，是不斷地邊等待邊檢查，因為會造成這樣的現象，我們也把這種 lock 稱為 spinlock。另外 available 這個變數只有 0 和 1 兩個值，這是一種簡單的工具&lt;/p&gt;
&lt;h3 id=&#34;semaphore&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#semaphore&#34;&gt;#&lt;/a&gt; Semaphore&lt;/h3&gt;
&lt;p&gt;semaphore 是一個整數變數，剛剛我們想要取得鑰匙必須使用 acquire，還鑰匙則是 release，在 Semaphore 中則是使用 wait and signal&lt;/p&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption data-lang=&#34;c&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token function&#34;&gt;wait&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;S&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt; &lt;span class=&#34;token keyword&#34;&gt;while&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;S&lt;span class=&#34;token operator&#34;&gt;&amp;lt;=&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt; S&lt;span class=&#34;token operator&#34;&gt;--&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token function&#34;&gt;signal&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;S&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;6&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  S&lt;span class=&#34;token operator&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;7&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;Semaphore 有 counting semaphore 和 binary semaphore，後者和 mutex 相同，前者則是整數型態，整數型態有一個好處，可以明確表示資源的數量，畢竟同步問題不只發生在修改共同變數，也可以是搶奪有限資源，舉例來說，今天要去停車場停車，發現停車場外面只寫了現在有空位或無空位就是 mutex，但如果寫剩於幾位就是 semaphore，semaphore 有可能小於 0 嗎？不可能&lt;br /&gt;
雖然執行 seamphore 大部分都是讓 semaphore 或 mutex 初值大於 0 ，但某先情況下我們可以修改初值讓 process 依照一定的次序執行&lt;br /&gt;
舉例來說 process 1 執行&lt;/p&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption data-lang=&#34;c&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;S1&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token function&#34;&gt;signal&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;synch&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;token comment&#34;&gt;//synch+1&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;process 2 執行&lt;/p&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption data-lang=&#34;c&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token function&#34;&gt;wait&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;synch&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;S2&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;這樣情況下 process 就會依照 process 1 先執行，再換 process 2 執行的次序&lt;br /&gt;
然而 semaphore 也會有 busy waiting 的問題，為甚麼 busy waiting 不好呢？因為在執行 wait () 函數時是不會被 context switch 的，等待太久就會浪費 CPU 時間。&lt;/p&gt;
&lt;h3 id=&#34;semaphore-implementation-with-no-busy-waiting&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#semaphore-implementation-with-no-busy-waiting&#34;&gt;#&lt;/a&gt; Semaphore Implementation with no Busy waiting&lt;/h3&gt;
&lt;p&gt;為了解決上面提到的問題，發展出沒有 busy waiting 的 semaphore，方法就是創立一個屬於 semaphore 的 queue，當 process 發現自己無法執行時就進到 queue 等待 ( &lt;strong&gt;block&lt;/strong&gt; ) ，執行完的 process 則會去 queue 呼叫下一個可以執行的 process ( &lt;strong&gt;wake up&lt;/strong&gt; )，此時 semaphore 也不再是一個普通的整數了，他變成這樣&lt;/p&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption data-lang=&#34;c&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;token keyword&#34;&gt;struct&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt; &lt;span class=&#34;token keyword&#34;&gt;int&lt;/span&gt; value&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt; &lt;span class=&#34;token keyword&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;token class-name&#34;&gt;process&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;*&lt;/span&gt;list&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;semaphore&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;而這個時候 value 值就有可能為負了，負表示有 process 在等待，而數字表示有幾個 process 在等待&lt;br /&gt;
原本的 wait () 和 signal () 函數則變成這樣&lt;/p&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption data-lang=&#34;c&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token function&#34;&gt;wait&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;semaphore &lt;span class=&#34;token operator&#34;&gt;*&lt;/span&gt;S&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt; S&lt;span class=&#34;token operator&#34;&gt;-&gt;&lt;/span&gt; value&lt;span class=&#34;token operator&#34;&gt;--&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt; &lt;span class=&#34;token keyword&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;S&lt;span class=&#34;token operator&#34;&gt;-&gt;&lt;/span&gt;value&lt;span class=&#34;token operator&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  add this process to S&lt;span class=&#34;token operator&#34;&gt;-&gt;&lt;/span&gt;list&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token function&#34;&gt;block&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;6&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt; &lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;7&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;8&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token function&#34;&gt;signal&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;semaphore &lt;span class=&#34;token operator&#34;&gt;*&lt;/span&gt;S&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;9&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt; S&lt;span class=&#34;token operator&#34;&gt;-&gt;&lt;/span&gt;value&lt;span class=&#34;token operator&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;10&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt; &lt;span class=&#34;token keyword&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;S&lt;span class=&#34;token operator&#34;&gt;-&gt;&lt;/span&gt;VALUE&lt;span class=&#34;token operator&#34;&gt;&amp;lt;=&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;11&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  remove a process P from S&lt;span class=&#34;token operator&#34;&gt;-&gt;&lt;/span&gt;list&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;12&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token function&#34;&gt;wakeup&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;P&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;13&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt; &lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;14&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;當我們沒寫好程式時系統可能會造成 deadlock，就是大家都卡住無法執行，下面這個情況就可能會造成 deadlock&lt;br /&gt;
 假設有 prosess p0 執行以下&lt;/p&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption data-lang=&#34;c&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token function&#34;&gt;wait&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;S&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token function&#34;&gt;wait&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;Q&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token function&#34;&gt;signal&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;S&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token function&#34;&gt;signal&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;Q&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;peocess p1 執行以下&lt;/p&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption data-lang=&#34;c&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token function&#34;&gt;wait&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;Q&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token function&#34;&gt;wait&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;S&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token function&#34;&gt;signal&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;Q&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token function&#34;&gt;signal&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;S&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;那麼對 p0 和 p1 而言，他們都拿不到他們想要的也都無法執行，就會造成系統卡住&lt;br /&gt;
如果在 semapgore queue 中安排不好，也可能會造成 starvation 。&lt;br /&gt;
另外有個名詞稱作 &lt;strong&gt;Priotity Inversion&lt;/strong&gt;，假設有一個高優先權的 process invoke 低優先權的 process 去拿取一個現在被中優先權掌握的資源，此時低優先權就會繼承高優先權的權力，順利從中優先權的 process 中搶過資源&lt;/p&gt;
&lt;h3 id=&#34;monitors&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#monitors&#34;&gt;#&lt;/a&gt; Monitors&lt;/h3&gt;
&lt;p&gt;Monitor 是一種資料型態，可以把他想成一個區域，進到這個區域之前要先排隊，進來之後也不是立刻執行喔，monitor 裡面的多個 process 只有一個能執行，在高階語言中我們使用這個架構，complier 會幫我們以 semaphores 的方式實作，monitor 大概長這樣&lt;/p&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption data-lang=&#34;c&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;monitor monitor&lt;span class=&#34;token operator&#34;&gt;-&lt;/span&gt;name&lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token comment&#34;&gt;//shared variable declarations&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt; procesdure &lt;span class=&#34;token function&#34;&gt;p1&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt; procedure  &lt;span class=&#34;token function&#34;&gt;pn&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt; initialization &lt;span class=&#34;token function&#34;&gt;code&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;6&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;在 monitor 的變數只有在 monitor 的 process 可以使用，在  monitor 的多個 process 只有一個可以執行，所以我們會使用 condition variable 來表示這些 process 的狀態，一般使用  &lt;code&gt;x.wait()&lt;/code&gt;  表示我在 monitor 中但我在等待， &lt;code&gt;x.signal()&lt;/code&gt;  則表示我在 monitor 中且我要執行，&lt;br /&gt;
為甚麼 x.signal () 示我要執行而不是我在執行呢？&lt;br /&gt;
那是因為 monitor 通常有兩種寫法，一種是當 a process  &lt;code&gt;x.signal() &lt;/code&gt; 時，b process 立刻進入  &lt;code&gt;x.wait()&lt;/code&gt; ，一種則是 a process x.signal () 但 CPU 沒有立刻執行 a process ，而是等到 b process 結束或離開 monitor 才執行，障兩種方式個又各地優缺點，端看 complier 如何實作&lt;/p&gt;
&lt;h3 id=&#34;monitor-implementation-using-semaphores&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#monitor-implementation-using-semaphores&#34;&gt;#&lt;/a&gt; Monitor Implementation Using Semaphores&lt;/h3&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption data-lang=&#34;c&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token comment&#34;&gt;//variables&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;semaphore mutex&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;token comment&#34;&gt;//(initially=1)&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;semaphore next&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;token comment&#34;&gt;//(initially=0)&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;int&lt;/span&gt; next_count&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token function&#34;&gt;wait&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;mutex&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;6&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;7&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;8&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;next_count&lt;span class=&#34;token operator&#34;&gt;&gt;&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;9&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token function&#34;&gt;signal&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;next&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;10&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;else&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;11&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token function&#34;&gt;signal&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;mutex&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;next_count 是表示有多少 process 在等待。當沒 process 等待時就把 mutex 設為 1 ， 表示大家都可以去爭奪那把鑰匙，有 process 在等待時，則呼叫等待隊伍中的下一個，至於要呼叫等待隊伍中的哪一個 process 就端看這個排序系統是使用 FCFS 或 Priority 等等，不同系統就會有不同設計&lt;/p&gt;
&lt;p&gt;以上就是 mutex、semaphores、monitors 的小科普，祝大家閱讀愉快&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://lu1hoao.github.io/2022/04/27/os/os-3/</guid>
            <title>Synchronization Tools (上)</title>
            <link>https://lu1hoao.github.io/2022/04/27/os/os-3/</link>
            <category>OS</category>
            <category>Synchronization</category>
            <pubDate>Wed, 27 Apr 2022 20:23:28 +0800</pubDate>
            <description><![CDATA[ &lt;h3 id=&#34;概要&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#概要&#34;&gt;#&lt;/a&gt; 概要&lt;/h3&gt;
&lt;p&gt;本文主要講述 Synchronization tools ，中文稱為同步，電腦中如果有兩個以上的 process 要存取同一個變數 (改變他的值) 我們必須確保這些變化是同步的不然就會造成同一個變數在不同 process 中有不同的值，本文主在討論&lt;strong&gt;確保他們是同步&lt;/strong&gt;的這個過程&lt;/p&gt;
&lt;h3 id=&#34;問題起源&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#問題起源&#34;&gt;#&lt;/a&gt; 問題起源&lt;/h3&gt;
&lt;p&gt;首先我們先來看下面這個情況，假設有兩個 process 互為 consumer 和 prodeucer 的關係，producer 完成一個任務後會把它放到 buffer ，consumer 則是會從 buffer 拿走任務，這時候就需要一個 counter 來記錄 buffer 內的任務數目，如果 counter 太小，就要叫 producer 做快一點，或者叫 consumer 拿慢一點，反之若 counter 太大，就要叫 producer 慢一點或 consumer 快一點，所以對 producer 來說他有以下程式碼&lt;/p&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption data-lang=&#34;c&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;while&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;true&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token keyword&#34;&gt;while&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;counter&lt;span class=&#34;token operator&#34;&gt;==&lt;/span&gt;BUFFER_SIZE&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  buffer&lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt;in&lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;next_produced&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  in&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;in&lt;span class=&#34;token operator&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;%&lt;/span&gt;BUFFER_SIZE&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  counter&lt;span class=&#34;token operator&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;6&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;為甚麼要  &lt;code&gt;%BUFFER_SIZE&lt;/code&gt;  呢？這是因為 buffer 的大小通常是有限的，後面放完又會從最前面開始放&lt;br /&gt;
對 consumer 來說他則有以下程式碼&lt;/p&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption data-lang=&#34;c&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;while&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;true&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token keyword&#34;&gt;while&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;counter&lt;span class=&#34;token operator&#34;&gt;==&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  next_consumed&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;buffer&lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt;out&lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  out&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;out&lt;span class=&#34;token operator&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;%&lt;/span&gt;BUFFER_SIZE&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  counter&lt;span class=&#34;token operator&#34;&gt;--&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;6&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;看起來非常合理，然而在 C 語言中， &lt;code&gt;counter++&lt;/code&gt;   &lt;code&gt;counter--&lt;/code&gt;  這樣一行程式碼，在組合語言中卻是三行&lt;/p&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption data-lang=&#34;c&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;register1&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;counter&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;register1&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;register1&lt;span class=&#34;token operator&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;counter&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;register1&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption data-lang=&#34;c&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;register2&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;counter&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;register2&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;register2&lt;span class=&#34;token operator&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;counter&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;register2&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;如果這三行沒有一口氣做完，而是做到一半就被 context switch ，那 counter 的值就不會被更新，為了解決這個問題，我們訂了 Critical section problem，對每一個 process 都有一段 code 表示 critical srction , 一旦這個 process 進到 critical section 就代表只有他能夠更改共同變數，其他人不可以更改！進到 critical section 要確認別人不在 critical section ，離開時也要把門打開讓別人可以進來，因此可以用下面程式碼範例簡單說明&lt;/p&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption data-lang=&#34;c&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;do&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  entrysection&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    critical section&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  exitsection&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    remainder section &lt;span class=&#34;token comment&#34;&gt;/* 非 critical section*/&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;6&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;h3 id=&#34;解法-petersons-solution&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#解法-petersons-solution&#34;&gt;#&lt;/a&gt; 解法 Peterson&#39;s Solution&lt;/h3&gt;
&lt;p&gt;一個正確的 critical section problem 解法，應該滿足以下三項&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Mutual Exclusion&lt;/strong&gt; ，互斥性，當我在 critical section 的時候別人都不能進&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Progress&lt;/strong&gt; ，運行順暢，大家都能很自由順利的進入 critical section 不會卡住&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Bounded Waiting&lt;/strong&gt;，等待時間短，避免有人輪不到&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Peterson&#39;s Solution 是這個問題的軟體解法，用以下程式說明&lt;/p&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption data-lang=&#34;c&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;do&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  flag&lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt;i&lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;true&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  turn&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;j&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token keyword&#34;&gt;while&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;flag&lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt;j&lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt;turn&lt;span class=&#34;token operator&#34;&gt;==&lt;/span&gt;j&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  critical section&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;6&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  flag&lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt;i&lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;false&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;7&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  remainder section    &lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;8&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;span class=&#34;token keyword&#34;&gt;while&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;true&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;假設現在輪到 process i，他想進去 critical section ，所以他就把自己的 flag 設為 1，但 critical section 不是他想進去就能進去的，必需沒有人在裡面，甚麼情況是有人在裡面？就是  &lt;code&gt;flag[j]==1&lt;/code&gt;  而且現在是 turn j (也就是說現在是輪到 process j)，那如果  &lt;code&gt;flag[j]!=1 &lt;/code&gt;  但 turn j 代表甚麼呢？代表 process j 可能已經死了，他無法自己拿起 flag 設為 1 ，那 turn i ， &lt;code&gt;flag[j]==1&lt;/code&gt;  ，代表雖然 process j 想進現在卻不是他的 turn ，他必須等到他的 turn 才能改，換句話說這是一個雙重確認的機制，有 flag 和 turn 兩個機制確保運作流暢，如果只保留這兩個中的其中一個，那上面提到三項標準的後兩項是無法滿足的&lt;/p&gt;
&lt;h3 id=&#34;synchronization-hardware&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#synchronization-hardware&#34;&gt;#&lt;/a&gt; Synchronization Hardware&lt;/h3&gt;
&lt;p&gt;有軟體解法也有硬體解法，而這兩種解法的觀念都圍繞著一個核心就是 locking ，我把自己鎖起來，沒人可以打斷我，因此硬體指令就是提供 atomic (non-interruptible)，我們用比較高階的語言來理解這些機器指令的原理，然而這其實是微指令&lt;br /&gt;
&lt;strong&gt; test_and_set Instructuon&lt;/strong&gt;&lt;br /&gt;
 (有共用的變數 lock，假設初始值是 FALSE，表示沒有其他 process 被 lock)&lt;/p&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption data-lang=&#34;c&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;boolean &lt;span class=&#34;token function&#34;&gt;test_and_set&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;boolean &lt;span class=&#34;token operator&#34;&gt;*&lt;/span&gt;target&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  boolean rv&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;*&lt;/span&gt;target&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token operator&#34;&gt;*&lt;/span&gt;target&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;TRUE&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token keyword&#34;&gt;return&lt;/span&gt; rv&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;6&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;do&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;7&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token keyword&#34;&gt;while&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token function&#34;&gt;test_and_set&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;&amp;amp;&lt;/span&gt;lock&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;8&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  critical section &lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;9&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  lock&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;false&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;10&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;span class=&#34;token keyword&#34;&gt;while&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;true&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;lock 就像軟體解法中的 turn ，而修改 target 的值就像軟體中把自己的 flag 設為 1 ，這個做法很厲害幾乎是現在通用的作法，不過這其實是 IBM 的專利，所以其他公司後來發展出 &lt;strong&gt;compare_and_swap Instruction&lt;/strong&gt; 但觀念是一樣的只是寫起來比較複雜&lt;/p&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption data-lang=&#34;c&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;compare_and_swqp&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token keyword&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;*&lt;/span&gt;value&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;token keyword&#34;&gt;int&lt;/span&gt; expected&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;token keyword&#34;&gt;int&lt;/span&gt; new_value&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token keyword&#34;&gt;int&lt;/span&gt; temp&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;*&lt;/span&gt;value&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token keyword&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;*&lt;/span&gt;value&lt;span class=&#34;token operator&#34;&gt;==&lt;/span&gt;expected&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    &lt;span class=&#34;token operator&#34;&gt;*&lt;/span&gt;value&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;new_value&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token keyword&#34;&gt;return&lt;/span&gt; temp&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;6&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;7&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;do&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;8&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token keyword&#34;&gt;while&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token function&#34;&gt;compare_and_swap&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;&amp;amp;&lt;/span&gt;lock&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;9&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  critical section&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;10&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  lock&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;11&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  remainder section&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;12&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;span class=&#34;token keyword&#34;&gt;while&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;true&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;以上就是實現 Synchronization 的方法，祝大家閱讀愉快&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://lu1hoao.github.io/2022/04/25/os/os-2/</guid>
            <title>CPU Scheduling (下)</title>
            <link>https://lu1hoao.github.io/2022/04/25/os/os-2/</link>
            <category>OS</category>
            <category>scheduling</category>
            <pubDate>Mon, 25 Apr 2022 20:23:28 +0800</pubDate>
            <description><![CDATA[ &lt;h3 id=&#34;概要&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#概要&#34;&gt;#&lt;/a&gt; 概要&lt;/h3&gt;
&lt;p&gt;本篇文章會先從 multilevel queue 說起，提到 thread scheduling 和 multiprocessor 排程所需注意的事情，最後說明 real-time system。&lt;/p&gt;
&lt;h3 id=&#34;multilevel-queue&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#multilevel-queue&#34;&gt;#&lt;/a&gt; Multilevel queue&lt;/h3&gt;
&lt;p&gt;對一個 CPU 有多條 ready queue 我們就稱為 multilevel queue，為甚麼一個 CPU 需要多條 queue 呢？只有一個服務台耶？不過現實生活中也會有這種情況，一間小吃店可能在同一時刻收到現場內用訂單和來自外送平台的訂單，這兩筆訂單來自不同的排隊系統，那小吃店應該先完成哪一筆呢？或許每家店都有不同的做法，對電腦來說也是如此，通常會有 foreground (前景) 和 batch (背景) 兩條 queue，foreground 是直接面對使用者的，所以電腦採取的排程做法多是 Round Roubin ，背景則是 First Come First Served， CPU 也會放不同的比重在這兩條 queue ，比如前景佔百分之 80 ，背景佔百分之 20 ，那一個 process 可以在不同 queue 之間跑來跑去嗎？如果可以我們就稱這種 queue  為 &lt;strong&gt;multilevel feedback queue&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;thread-scheduling&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#thread-scheduling&#34;&gt;#&lt;/a&gt; Thread Scheduling&lt;/h3&gt;
&lt;p&gt;thread 中文叫做執行緒，一個 process 由很多 thread 組成，可以視為小的執行單位，對 user-level 的 thread 來說和她一起競爭  CPU 資源的是和他同屬一個 process 的其他 thread ，我們稱為 process-contention scope (PCS)，對 kernel-thread 則是 system-contention scope (SCS)，和所有系統中的 thread 競爭資源&lt;/p&gt;
&lt;h3 id=&#34;multiple-processor-scheduling&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#multiple-processor-scheduling&#34;&gt;#&lt;/a&gt; Multiple-Processor Scheduling&lt;/h3&gt;
&lt;p&gt;現在的電腦多是 Symmetric multiprocessing (SMP)，亦即每一個 CPU 都可以執行排程，所有 process 會在一條共有的 ready queue 等待被執行，或者每一個 CPU 都有獨立的 queue 存放等待被執行的 process，然而在多個 CPU 的情況下存在著 Non Uniform Memory Access， CPU 在自己家的 memory 存取速度比較快，在別人家的比較慢，換句話說，原本有一個 process 在 A CPU 執行，接著要換去 B CPU 執行， B CPU 要去 A 那裡拿資料就比較慢。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://i.imgur.com/H1vIZ8l.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;不想要讓這種事情太常發生我們就需要 &lt;strong&gt;Processor affinity&lt;/strong&gt; (親和性)，換句話說就是要儘可能讓同一個 process 在同一個 CPU 上面跑。&lt;br /&gt;
另外之前也說過，在電腦裡面不可以有倘分仔是很重要的概念，所以每個 CPU 的工作量要平均，稱為 Load balancing，有 &lt;strong&gt;Push migration&lt;/strong&gt; 和 &lt;strong&gt;Pull migration&lt;/strong&gt; 兩種做法，前者是多的給少的，比如規定每個 CPU 的工作不得超過十件， CPU A 有 12 件，他就問：有沒有人有空幫我做呀？，這時 B 舉手，他只有 6 件，所以 A 就把工作分給 B，後者則是 B 看到 A 超過 10 件，而自己沒有，於是發揮暖男精神主動跑去幫忙 A。&lt;/p&gt;
&lt;h3 id=&#34;multicore-processor&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#multicore-processor&#34;&gt;#&lt;/a&gt; Multicore Processor&lt;/h3&gt;
&lt;p&gt;對 multicore system 而言，我們通常會派發不只一條 thread 給一個 core ，因為當 processor 要去存取 memory 而耗費大量時間時我們稱為 memory stall，當一個 thread 還在等待 memory 時 (遭遇  memory stall) 我們就先執行另一個 thread，以提高速率，下圖以黃色表示 compute cycle，藍色表示 memory stall cycle&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://i.imgur.com/bpIH6SW.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;h3 id=&#34;real-time-cpu-scheduling&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#real-time-cpu-scheduling&#34;&gt;#&lt;/a&gt; Real-time CPU Scheduling&lt;/h3&gt;
&lt;p&gt;對某些電腦而言他們要執行的動作其實是週期性重複的，比如裝在衛星上的電腦，衛星拍攝一張照片、攝影機冷卻、調整衛星位置、再拍一張照片，就是這幾個動作在重複，不會突然跑出：喂，電腦給我播放 youtube 影片這樣的要求，但這些指令卻是一定要被執行的，試想核電廠的運作如果有一個指令突然沒執行，就可能會造成難以承受的災害，這種指令一定要在一個期限內完成的系統稱為  &lt;strong&gt;real-time system&lt;/strong&gt; 這種系統通常用 priority system ，&lt;strong&gt;而重複週期越短的 process 優先權越高&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以上就是 CPU 排程下篇，這裡提到的都只是簡單的小科普，其實每一個主題背後都有更深入的技術值得探討，比如為甚麼會有 memory stall 呢？因為 cache miss，不過再討論下去，篇幅就太長了，希望大家讀完有收穫。&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://lu1hoao.github.io/2022/04/23/os/os-1/</guid>
            <title>CPU Scheduling (上)</title>
            <link>https://lu1hoao.github.io/2022/04/23/os/os-1/</link>
            <category>OS</category>
            <category>scheduling</category>
            <pubDate>Sat, 23 Apr 2022 20:23:28 +0800</pubDate>
            <description><![CDATA[ &lt;h3 id=&#34;概要&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#概要&#34;&gt;#&lt;/a&gt; 概要&lt;/h3&gt;
&lt;p&gt;對現在電腦而言，排程是一件很重要的技術，打開電腦有很多事情想做，又很希望電腦趕快做完，就算沒有真的在做也給我們一點回應，讓我們知道他需要一點時間處理，本文主要探討常見的 CPU 排程方法 (包含 mulititasking 和 multiple-processor (下篇))&lt;/p&gt;
&lt;h3 id=&#34;評估標準-criteria&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#評估標準-criteria&#34;&gt;#&lt;/a&gt; 評估標準 Criteria&lt;/h3&gt;
&lt;p&gt;由於人類具有慣老闆天性，對於電腦這種不會抱怨的員工更是要求一人當三人用一刻不得閒，所以我們評估排程好壞的標準大概可以由以下幾點決定&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;CPU utilization&lt;/strong&gt; (CPU 使用率) 指的是 CPU 工作的時間，絕對是越高越好， CPU 不准休息 ，就算是在多處理器的系統，也要讓每顆 CPU 工作分配平均 (大家都很忙，不能有躺分仔的概念)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Throughput&lt;/strong&gt; (產能) 單位時間內能完成的工作越多越好，所以這個值也是越高越好&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Turnaround time&lt;/strong&gt; (從開始執行到結束的時間) 希望能夠越快做完越好，所以這個數值是越低越好&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Waiting time&lt;/strong&gt; 一個 process 在 ready queue 等待的時間，就像我們去郵局從抽號碼牌到被叫到的這段時間，等待時間越短越好，所以數值越小越好&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Response time&lt;/strong&gt; (回應時間) 這在電腦裡面是很重要的，告訴使用者我有在動啦不要再叫了！我們點兩下滑鼠打開一個程式，游標會出現一個藍色圈圈在轉，就算該軟體介面還沒出現在螢幕上，我們看到藍色圈圈也會安心不少，就不會一直瘋狂點滑鼠，回應時間越短越好，所以數值越小越好&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;了解以上幾點評估標準後我們就可以更進一步來比較各種排程方法&lt;/p&gt;
&lt;h3 id=&#34;為何需要排程&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#為何需要排程&#34;&gt;#&lt;/a&gt; 為何需要排程&lt;/h3&gt;
&lt;p&gt;multitasking 是說 CPU 可以同時一次處理好幾個 process 但這裡的同時並不是說 CPU 像千手觀音那樣，同一時刻處理好多事情，而是說 CPU 先做 A process ，做一下子後儲存 A 的狀態再換去做 B ，B 做完一些後再回來做 A ，在一段時間內多處跑的概念，到這裡人類可能會想這是哪門子的同時呀，但電腦執行的速度很快，在人類有感時間一秒內，電腦可能已經處理完好幾個 process 了，既然 CPU 是這樣在 process 之間來回走跳，決定他下一步該去哪個 process 就很重要，也是排程的精髓&lt;/p&gt;
&lt;h3 id=&#34;過程&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#過程&#34;&gt;#&lt;/a&gt; 過程&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Short-term-scheuler 會從 ready queue 挑選一個要被執行的 process 給 CPU ，這個過程稱為 Dispatch&lt;/li&gt;
&lt;li&gt;CPU 做到一個程度後 (這個程度會依據不同的排程演算法而有不一樣的條件) 做 context switch (在 context switch 之前 重複第一步驟)&lt;/li&gt;
&lt;li&gt;CPU 執行第二個 process 直到達到終止條件&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;這三步驟不斷重複直到我們把電腦關機&lt;/p&gt;
&lt;h3 id=&#34;常見演算法&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#常見演算法&#34;&gt;#&lt;/a&gt; 常見演算法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;First Come First Served&lt;/strong&gt; (FCFS) 先進先出，最直覺的排序方式，先到 ready queue 的就先執行，直到做完再換下一個，然而這樣的排程方法無法保證 waiting time 最低，以下方例子來說，有三個 process 執行時間分別是 6,4,2 ，照以下順序執行，平均等待時間為 (6+4)/3&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://i.imgur.com/BD6CXb7.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;但如果把執行順序改成這樣，平均等待時間就變成 (4+2)/6&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://i.imgur.com/n2YCvwB.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;換句話說，&lt;strong&gt;當三個 process 在差不多時間抵達時&lt;/strong&gt;，&lt;strong&gt;把時間短的作為第一個效果會比較好&lt;/strong&gt;，如果完全依照先進先出反而會在某些情況浪費時間，這樣的想法進而引發 shortest job first 的排程技術&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Shortest job first&lt;/strong&gt; (SJF) 時間短的先進行，這種排程方法是 optimal (最佳的)，能確保最短的 waiting time ，但我們要如何預測 process 的執行時間呢？假設我們現在執行第 n 個 process ，第 n+1 個 process 執行時間可預測為 (預測和真實不同)&lt;br /&gt;
&lt;img data-src=&#34;https://i.imgur.com/4WI49j3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;其中 t 表示真實的時間。&lt;br /&gt;
除了一般的 SJF 排程，還有一種是 preemptive 的 SJF，所謂的 preemptive 是搶先的，當現在出現一個比 CPU 正在執行的 process 所需時間更短的 process 時， CPU 會先把手上的工作做完再去執行他呢？還是立刻剔除現在在執行的，換到他？如果是後者稱為 preemptive，而 preemptive 的 SJF 就是 &lt;strong&gt;shortest-remaining-time-first&lt;/strong&gt;，我們以下面例子說明&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://i.imgur.com/r1Bt5gs.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://i.imgur.com/EtmSz8x.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;時間為 1 時， B 抵達因為所需時間比 A 少，所以立即停止做 A 改做 B ，時間為 5 時，B 已經做完，D 所需時間最少所以做 D ，依此類推&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Priority Scheduling&lt;/strong&gt; (優先權排序)，這種把事情程度分級的做法在生活中很常見，比如醫療上常見的檢傷分類，把最緊急最有生命危險的作為最先救助，其實 SJF 也算一種 Priority Scheduling 只是他的評估標是時間，對電腦而言常見的優先順序依序是&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;system processes&lt;/li&gt;
&lt;li&gt;interactive processes&lt;/li&gt;
&lt;li&gt;interactive editing processes&lt;/li&gt;
&lt;li&gt;batch processes&lt;/li&gt;
&lt;li&gt;student processes&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;到這裡難免有些難過 student process 竟然最低，然而平常寫程式資料量通常都很小所以跑很快 &amp;gt; &amp;lt;(老師叫我們不要灰心)&lt;br /&gt;
 Priority Scheduling 雖然很符合人的理想，事情有輕重緩急，確實本該分類，然而會造成 &lt;strong&gt;Starvation&lt;/strong&gt; ，當有大型傳染病發生時，醫院的醫療資源可能就會被大量的傳染病患者佔據，壓縮到原先非傳染病患者的資源 (比如需長時間治療的慢性病)，最後這些慢性病患者可能就會因為資源不足而病情惡化，Starvation 就是在形容這種狀況，因為優先權太低而等不到資源最後無法被執行，解決 starvation 的方法是 &lt;strong&gt;Aging&lt;/strong&gt;，每隔一段時間就提升在等待的 process 的優先權，比如 A process 原本優先權是 3 ，他在 ready queue 等一段時間後便上升為 2 ，只要等得夠久有一天一定能變成優先權最高最先被執行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Round Roubine&lt;/strong&gt;，這種排程方式在生活中也很常見，假設一群人到遊樂園玩海盜船，玩完一次 10 分鐘，覺得意猶未盡還想再玩該怎麼辦呢？就要離開遊戲區到外面重排直到又輪到自己 ，Round Roubin 就是這樣，把時間切成好幾塊，每個人執行一次，若還沒跑完再重新排，因此時間區塊的大小很重要，如果切太大，每個人都在一塊時間內就跑玩那就和 FCFS 沒兩樣，如果時間切太小塊，又會浪費太多時間在做 context switch 我們以下面例子來說明，假設每塊時間為 4&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://i.imgur.com/lhWsqX7.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://i.imgur.com/HXYWl7m.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上就是目前電腦常見的排程方式，我在下篇會提到 multi queue (多個 ready queue) 以及 multiple processor 所需的注意事項和 real-time system&lt;/p&gt;
 ]]></description>
        </item>
    </channel>
</rss>
