{
    "version": "https://jsonfeed.org/version/1",
    "title": "Lu Ying's home • All posts by \"scheduling\" tag",
    "description": "生活紀錄",
    "home_page_url": "https://lu1hOAO.github.io",
    "items": [
        {
            "id": "https://lu1hoao.github.io/2022/04/25/os/os-2/",
            "url": "https://lu1hoao.github.io/2022/04/25/os/os-2/",
            "title": "CPU Scheduling (下)",
            "date_published": "2022-04-25T12:23:28.000Z",
            "content_html": "<h3 id=\"概要\"><a class=\"anchor\" href=\"#概要\">#</a> 概要</h3>\n<p>本篇文章會先從 multilevel queue 說起，提到 thread scheduling 和 multiprocessor 排程所需注意的事情，最後說明 real-time system。</p>\n<h3 id=\"multilevel-queue\"><a class=\"anchor\" href=\"#multilevel-queue\">#</a> Multilevel queue</h3>\n<p>對一個 CPU 有多條 ready queue 我們就稱為 multilevel queue，為甚麼一個 CPU 需要多條 queue 呢？只有一個服務台耶？不過現實生活中也會有這種情況，一間小吃店可能在同一時刻收到現場內用訂單和來自外送平台的訂單，這兩筆訂單來自不同的排隊系統，那小吃店應該先完成哪一筆呢？或許每家店都有不同的做法，對電腦來說也是如此，通常會有 foreground (前景) 和 batch (背景) 兩條 queue，foreground 是直接面對使用者的，所以電腦採取的排程做法多是 Round Roubin ，背景則是 First Come First Served， CPU 也會放不同的比重在這兩條 queue ，比如前景佔百分之 80 ，背景佔百分之 20 ，那一個 process 可以在不同 queue 之間跑來跑去嗎？如果可以我們就稱這種 queue  為 <strong>multilevel feedback queue</strong>。</p>\n<h3 id=\"thread-scheduling\"><a class=\"anchor\" href=\"#thread-scheduling\">#</a> Thread Scheduling</h3>\n<p>thread 中文叫做執行緒，一個 process 由很多 thread 組成，可以視為小的執行單位，對 user-level 的 thread 來說和她一起競爭  CPU 資源的是和他同屬一個 process 的其他 thread ，我們稱為 process-contention scope (PCS)，對 kernel-thread 則是 system-contention scope (SCS)，和所有系統中的 thread 競爭資源</p>\n<h3 id=\"multiple-processor-scheduling\"><a class=\"anchor\" href=\"#multiple-processor-scheduling\">#</a> Multiple-Processor Scheduling</h3>\n<p>現在的電腦多是 Symmetric multiprocessing (SMP)，亦即每一個 CPU 都可以執行排程，所有 process 會在一條共有的 ready queue 等待被執行，或者每一個 CPU 都有獨立的 queue 存放等待被執行的 process，然而在多個 CPU 的情況下存在著 Non Uniform Memory Access， CPU 在自己家的 memory 存取速度比較快，在別人家的比較慢，換句話說，原本有一個 process 在 A CPU 執行，接著要換去 B CPU 執行， B CPU 要去 A 那裡拿資料就比較慢。</p>\n<p><img data-src=\"https://i.imgur.com/H1vIZ8l.png\" alt=\"\" /></p>\n<p>不想要讓這種事情太常發生我們就需要 <strong>Processor affinity</strong> (親和性)，換句話說就是要儘可能讓同一個 process 在同一個 CPU 上面跑。<br />\n另外之前也說過，在電腦裡面不可以有倘分仔是很重要的概念，所以每個 CPU 的工作量要平均，稱為 Load balancing，有 <strong>Push migration</strong> 和 <strong>Pull migration</strong> 兩種做法，前者是多的給少的，比如規定每個 CPU 的工作不得超過十件， CPU A 有 12 件，他就問：有沒有人有空幫我做呀？，這時 B 舉手，他只有 6 件，所以 A 就把工作分給 B，後者則是 B 看到 A 超過 10 件，而自己沒有，於是發揮暖男精神主動跑去幫忙 A。</p>\n<h3 id=\"multicore-processor\"><a class=\"anchor\" href=\"#multicore-processor\">#</a> Multicore Processor</h3>\n<p>對 multicore system 而言，我們通常會派發不只一條 thread 給一個 core ，因為當 processor 要去存取 memory 而耗費大量時間時我們稱為 memory stall，當一個 thread 還在等待 memory 時 (遭遇  memory stall) 我們就先執行另一個 thread，以提高速率，下圖以黃色表示 compute cycle，藍色表示 memory stall cycle</p>\n<p><img data-src=\"https://i.imgur.com/bpIH6SW.png\" alt=\"\" /></p>\n<h3 id=\"real-time-cpu-scheduling\"><a class=\"anchor\" href=\"#real-time-cpu-scheduling\">#</a> Real-time CPU Scheduling</h3>\n<p>對某些電腦而言他們要執行的動作其實是週期性重複的，比如裝在衛星上的電腦，衛星拍攝一張照片、攝影機冷卻、調整衛星位置、再拍一張照片，就是這幾個動作在重複，不會突然跑出：喂，電腦給我播放 youtube 影片這樣的要求，但這些指令卻是一定要被執行的，試想核電廠的運作如果有一個指令突然沒執行，就可能會造成難以承受的災害，這種指令一定要在一個期限內完成的系統稱為  <strong>real-time system</strong> 這種系統通常用 priority system ，<strong>而重複週期越短的 process 優先權越高</strong></p>\n<p>以上就是 CPU 排程下篇，這裡提到的都只是簡單的小科普，其實每一個主題背後都有更深入的技術值得探討，比如為甚麼會有 memory stall 呢？因為 cache miss，不過再討論下去，篇幅就太長了，希望大家讀完有收穫。</p>\n",
            "tags": [
                "OS",
                "scheduling"
            ]
        },
        {
            "id": "https://lu1hoao.github.io/2022/04/23/os/os-1/",
            "url": "https://lu1hoao.github.io/2022/04/23/os/os-1/",
            "title": "CPU Scheduling (上)",
            "date_published": "2022-04-23T12:23:28.000Z",
            "content_html": "<h3 id=\"概要\"><a class=\"anchor\" href=\"#概要\">#</a> 概要</h3>\n<p>對現在電腦而言，排程是一件很重要的技術，打開電腦有很多事情想做，又很希望電腦趕快做完，就算沒有真的在做也給我們一點回應，讓我們知道他需要一點時間處理，本文主要探討常見的 CPU 排程方法 (包含 mulititasking 和 multiple-processor (下篇))</p>\n<h3 id=\"評估標準-criteria\"><a class=\"anchor\" href=\"#評估標準-criteria\">#</a> 評估標準 Criteria</h3>\n<p>由於人類具有慣老闆天性，對於電腦這種不會抱怨的員工更是要求一人當三人用一刻不得閒，所以我們評估排程好壞的標準大概可以由以下幾點決定</p>\n<ol>\n<li><strong>CPU utilization</strong> (CPU 使用率) 指的是 CPU 工作的時間，絕對是越高越好， CPU 不准休息 ，就算是在多處理器的系統，也要讓每顆 CPU 工作分配平均 (大家都很忙，不能有躺分仔的概念)</li>\n<li><strong>Throughput</strong> (產能) 單位時間內能完成的工作越多越好，所以這個值也是越高越好</li>\n<li><strong>Turnaround time</strong> (從開始執行到結束的時間) 希望能夠越快做完越好，所以這個數值是越低越好</li>\n<li><strong>Waiting time</strong> 一個 process 在 ready queue 等待的時間，就像我們去郵局從抽號碼牌到被叫到的這段時間，等待時間越短越好，所以數值越小越好</li>\n<li><strong>Response time</strong> (回應時間) 這在電腦裡面是很重要的，告訴使用者我有在動啦不要再叫了！我們點兩下滑鼠打開一個程式，游標會出現一個藍色圈圈在轉，就算該軟體介面還沒出現在螢幕上，我們看到藍色圈圈也會安心不少，就不會一直瘋狂點滑鼠，回應時間越短越好，所以數值越小越好</li>\n</ol>\n<p>了解以上幾點評估標準後我們就可以更進一步來比較各種排程方法</p>\n<h3 id=\"為何需要排程\"><a class=\"anchor\" href=\"#為何需要排程\">#</a> 為何需要排程</h3>\n<p>multitasking 是說 CPU 可以同時一次處理好幾個 process 但這裡的同時並不是說 CPU 像千手觀音那樣，同一時刻處理好多事情，而是說 CPU 先做 A process ，做一下子後儲存 A 的狀態再換去做 B ，B 做完一些後再回來做 A ，在一段時間內多處跑的概念，到這裡人類可能會想這是哪門子的同時呀，但電腦執行的速度很快，在人類有感時間一秒內，電腦可能已經處理完好幾個 process 了，既然 CPU 是這樣在 process 之間來回走跳，決定他下一步該去哪個 process 就很重要，也是排程的精髓</p>\n<h3 id=\"過程\"><a class=\"anchor\" href=\"#過程\">#</a> 過程</h3>\n<ol>\n<li>Short-term-scheuler 會從 ready queue 挑選一個要被執行的 process 給 CPU ，這個過程稱為 Dispatch</li>\n<li>CPU 做到一個程度後 (這個程度會依據不同的排程演算法而有不一樣的條件) 做 context switch (在 context switch 之前 重複第一步驟)</li>\n<li>CPU 執行第二個 process 直到達到終止條件</li>\n</ol>\n<p>這三步驟不斷重複直到我們把電腦關機</p>\n<h3 id=\"常見演算法\"><a class=\"anchor\" href=\"#常見演算法\">#</a> 常見演算法</h3>\n<ul>\n<li>\n<p><strong>First Come First Served</strong> (FCFS) 先進先出，最直覺的排序方式，先到 ready queue 的就先執行，直到做完再換下一個，然而這樣的排程方法無法保證 waiting time 最低，以下方例子來說，有三個 process 執行時間分別是 6,4,2 ，照以下順序執行，平均等待時間為 (6+4)/3</p>\n<p><img data-src=\"https://i.imgur.com/BD6CXb7.png\" alt=\"\" /></p>\n<p>但如果把執行順序改成這樣，平均等待時間就變成 (4+2)/6</p>\n<p><img data-src=\"https://i.imgur.com/n2YCvwB.png\" alt=\"\" /></p>\n<p>換句話說，<strong>當三個 process 在差不多時間抵達時</strong>，<strong>把時間短的作為第一個效果會比較好</strong>，如果完全依照先進先出反而會在某些情況浪費時間，這樣的想法進而引發 shortest job first 的排程技術</p>\n</li>\n<li>\n<p><strong>Shortest job first</strong> (SJF) 時間短的先進行，這種排程方法是 optimal (最佳的)，能確保最短的 waiting time ，但我們要如何預測 process 的執行時間呢？假設我們現在執行第 n 個 process ，第 n+1 個 process 執行時間可預測為 (預測和真實不同)<br />\n<img data-src=\"https://i.imgur.com/4WI49j3.png\" alt=\"\" /></p>\n<p>其中 t 表示真實的時間。<br />\n除了一般的 SJF 排程，還有一種是 preemptive 的 SJF，所謂的 preemptive 是搶先的，當現在出現一個比 CPU 正在執行的 process 所需時間更短的 process 時， CPU 會先把手上的工作做完再去執行他呢？還是立刻剔除現在在執行的，換到他？如果是後者稱為 preemptive，而 preemptive 的 SJF 就是 <strong>shortest-remaining-time-first</strong>，我們以下面例子說明</p>\n<p><img data-src=\"https://i.imgur.com/r1Bt5gs.png\" alt=\"\" /></p>\n<p><img data-src=\"https://i.imgur.com/EtmSz8x.png\" alt=\"\" /></p>\n<p>時間為 1 時， B 抵達因為所需時間比 A 少，所以立即停止做 A 改做 B ，時間為 5 時，B 已經做完，D 所需時間最少所以做 D ，依此類推</p>\n</li>\n<li>\n<p><strong>Priority Scheduling</strong> (優先權排序)，這種把事情程度分級的做法在生活中很常見，比如醫療上常見的檢傷分類，把最緊急最有生命危險的作為最先救助，其實 SJF 也算一種 Priority Scheduling 只是他的評估標是時間，對電腦而言常見的優先順序依序是</p>\n<ol>\n<li>system processes</li>\n<li>interactive processes</li>\n<li>interactive editing processes</li>\n<li>batch processes</li>\n<li>student processes</li>\n</ol>\n<p>到這裡難免有些難過 student process 竟然最低，然而平常寫程式資料量通常都很小所以跑很快 &gt; &lt;(老師叫我們不要灰心)<br />\n Priority Scheduling 雖然很符合人的理想，事情有輕重緩急，確實本該分類，然而會造成 <strong>Starvation</strong> ，當有大型傳染病發生時，醫院的醫療資源可能就會被大量的傳染病患者佔據，壓縮到原先非傳染病患者的資源 (比如需長時間治療的慢性病)，最後這些慢性病患者可能就會因為資源不足而病情惡化，Starvation 就是在形容這種狀況，因為優先權太低而等不到資源最後無法被執行，解決 starvation 的方法是 <strong>Aging</strong>，每隔一段時間就提升在等待的 process 的優先權，比如 A process 原本優先權是 3 ，他在 ready queue 等一段時間後便上升為 2 ，只要等得夠久有一天一定能變成優先權最高最先被執行</p>\n</li>\n<li>\n<p><strong>Round Roubine</strong>，這種排程方式在生活中也很常見，假設一群人到遊樂園玩海盜船，玩完一次 10 分鐘，覺得意猶未盡還想再玩該怎麼辦呢？就要離開遊戲區到外面重排直到又輪到自己 ，Round Roubin 就是這樣，把時間切成好幾塊，每個人執行一次，若還沒跑完再重新排，因此時間區塊的大小很重要，如果切太大，每個人都在一塊時間內就跑玩那就和 FCFS 沒兩樣，如果時間切太小塊，又會浪費太多時間在做 context switch 我們以下面例子來說明，假設每塊時間為 4</p>\n<p><img data-src=\"https://i.imgur.com/lhWsqX7.png\" alt=\"\" /></p>\n<p><img data-src=\"https://i.imgur.com/HXYWl7m.png\" alt=\"\" /></p>\n</li>\n</ul>\n<p>以上就是目前電腦常見的排程方式，我在下篇會提到 multi queue (多個 ready queue) 以及 multiple processor 所需的注意事項和 real-time system</p>\n",
            "tags": [
                "OS",
                "scheduling"
            ]
        }
    ]
}