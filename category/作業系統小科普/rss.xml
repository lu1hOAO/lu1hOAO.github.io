<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title>Lu Ying • Posts by &#34;作業系統小科普&#34; category</title>
        <link>https://lu1hoao.github.io</link>
        <description></description>
        <language>en</language>
        <pubDate>Thu, 12 May 2022 21:23:28 +0800</pubDate>
        <lastBuildDate>Thu, 12 May 2022 21:23:28 +0800</lastBuildDate>
        <category>OS</category>
        <category>scheduling</category>
        <category>Synchronization</category>
        <category>Deadlock</category>
        <category>Memory</category>
        <category>permutation</category>
        <category>C</category>
        <category>combination</category>
        <category>程式新手</category>
        <category>Visual studio 2022</category>
        <category>sort</category>
        <category>VS Code</category>
        <category>WSL</category>
        <category>debug</category>
        <item>
            <guid isPermalink="true">https://lu1hoao.github.io/2022/05/12/os/os-9/</guid>
            <title>Main Memory (下)</title>
            <link>https://lu1hoao.github.io/2022/05/12/os/os-9/</link>
            <category>OS</category>
            <category>Memory</category>
            <pubDate>Thu, 12 May 2022 21:23:28 +0800</pubDate>
            <description><![CDATA[ &lt;h3 id=&#34;概要&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#概要&#34;&gt;#&lt;/a&gt; 概要&lt;/h3&gt;
&lt;p&gt;本篇文主要講述 page table 和更多 paging 細節，並對整個 main maemory 做回顧，強烈建議搭配上篇一同觀看&lt;/p&gt;
&lt;h3 id=&#34;implementation-of-page-table&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#implementation-of-page-table&#34;&gt;#&lt;/a&gt; Implementation of Page Table&lt;/h3&gt;
&lt;p&gt;依照上篇提過的 page 方法，我們發現從 page 轉到 frame 需要一個 page table ，而這個 page table 就存在 memory 裡，然而問題來了，我們把資料放進 memory 得過程竟然要存取兩次 memory (一次到 page pagetable 一次到 frame) 這樣也太沒效率了吧！因此我們把 page table 放在一個類似 cache 的硬體，稱作 translation look-aside buffers (TLBs)，如果我們要找的 page 沒出現在 TLB ，這時候稱為 miss ，我們必須到主記憶體去把他的轉換資料找出來並放到 TLB 內，但有了 TLB 這個硬體可以大幅幫助我們提升效率&lt;br /&gt;
加了 TLB 的 address transfer 如下圖&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://i.imgur.com/NZVxgy8.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;h3 id=&#34;effevtive-access-time&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#effevtive-access-time&#34;&gt;#&lt;/a&gt; Effevtive Access Time&lt;/h3&gt;
&lt;p&gt;雖然字面上說增加 TLB 可以提高效率，但還是很沒有實感，那我們就來看看一個例子吧：&lt;br /&gt;
假設 TLB 的存取速度是 20ns ，記憶體的存取速度是 100ns ，有百分之八十的 page 在 TLB 當中就可以取得轉換資訊，那麼平均存取時間就是&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://i.imgur.com/XKke5l4.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;意義是有百分之八十的 page 存取一次 TLB 存取一次 memory ，百分之二十的 page ，存取一次 TLB 沒找到，又再去 page table 找 (存取第一次記憶體) 找到 fram number 後又存取第二次記憶體&lt;br /&gt;
因此若有越高的比率可以在 TLB 就找到資訊，存取速度就會越快&lt;/p&gt;
&lt;h3 id=&#34;memory-protection&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#memory-protection&#34;&gt;#&lt;/a&gt; Memory Protection&lt;/h3&gt;
&lt;p&gt;Page table 除了給予 page 對應到 frame 的位置資訊，也會有一些 bit 記錄這些 page 的其他資訊，像是 valid-invalid bit，因為同一時刻 page table 內可能會有多個 process 的資訊，要避免存取到不是自己的 page ，又或者紀錄這個 page 是否被更動過。對於某些共用部分 code 的 process 而言，我們把這些 shared code 稱為 reentrant，含有這些 code 的 page 可能就會常駐在 TLB 中，一般而言，每次 context switch ，TLB 和 page table 也要被更新&lt;/p&gt;
&lt;h3 id=&#34;structure-of-page-table&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#structure-of-page-table&#34;&gt;#&lt;/a&gt; Structure of page table&lt;/h3&gt;
&lt;p&gt;前面提過 page table 的大小和 page size 有關，假設今天有個 process 的資訊量是 2 的 32 次方，而 page size 是 4KB (2 的 12 次方)，所以這個 process 會用掉 1M ( 2 的 20 次方 ) 個 page，換句話說會有 1M 個 page 地址，假設每個地址需要 4 byte 空間，1M 個地址就會佔去 4M ，佔據記憶體 4M 的空間實在太大了，更何況我們不一定會真正利用到 page table 中的每項資訊，因此如何使放在記憶體當中的資訊不要那麼多，就發展出了以下三種作法&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Hierarchical Paging&lt;/li&gt;
&lt;li&gt;Hashed Page Tables&lt;/li&gt;
&lt;li&gt;Inverted Page Tables&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其中，Hierarchical Paging 又被稱為 multi-level paging 或 Two-level paging 或 forward-mapped paging ，是實務上最常見的方法&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Hierarchical Paging&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;是把 page table 在做分割，假設現在圖書館有 1000 本書，我們分成 100 個書架，每個書架有 10 本書，要找一本書的時候就先看他在哪一個書架再去該書架找 (這是原本的 page) 現在又把這 100 個書架分成 10 區，每區有 10 個書架，要找一本書的時候先看他在哪一區，再看他在該區的哪一個書架，最後再到該書架的 10 本書中去找，後者就是 Two-level paging&lt;/p&gt;
&lt;p&gt;原本的 logical address 包含兩個部分，一個是 page number ，一個是 offset ，page number 表示該 page 在 page table 的 index，現在我們把 page number 切成兩個部分，一個表示他對應到哪一個 page table  (又稱 outer page)，一個表示他在該 page table 中的 index (又稱 inner page)。&lt;/p&gt;
&lt;p&gt;我們把圖書館的例子用圖片說明，單純的 page 收到以下訊號&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://i.imgur.com/kb8lRiZ.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;代表第 83 個書架中的第六本書，而這個圖書館必須在門口張貼一張表，表上有 100 個書架的位置&lt;/p&gt;
&lt;p&gt;two level paging 收到這樣的訊號則會做以下解讀&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://i.imgur.com/sglq3Z8.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;代表第 8 區、第 3 個書架、第 6 本書，而這個圖書館必須張貼一張表，表上有 10 個區域的位置，每個區域入口處也要有屬於該區 10 個書架的位置。&lt;/p&gt;
&lt;p&gt;對記憶體而言 (相當於對圖書館而言) 他需要紀錄的東西從 100 個書架的位址縮小成 10 個區域的位置，減少了很大的負擔。對 CPU 而言 (相當於要找書的人而言)，也不需要修改自己表示資訊的方式 (address 長度不變)，只要換個角度看待資訊就好了。在主記憶體當中只需要存放一個 page table (即圖書館門口的區域位置表)，對每一個 page table 而言，專屬於他們的第二層 page table (相當於各區域門口的書架位址) 放在 disk 即可，需要的時候再去拿，而拿取的技術可以使用前一篇文章提到的 memory image&lt;br /&gt;
 在 two level paging 中會收到兩個位址資訊，其中第一個位址資訊又會成為第二個位址資訊的查詢基礎，有點指來指去的概念。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Hashed Page Table&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;顧名思義就是利用雜湊函數對資料作處理，在主記憶體當中存放雜湊表，假設收到以下資訊&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://i.imgur.com/mPu26jr.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;我們先把 83 mod 7 ，發現餘 6 ，於是找到第六項在去做更進一步處理，看是利用 linklist 或是第二個 page table 還是怎樣都可以，但主記憶體當中只需要存取一個有 7 個項目的雜湊表 (餘數從 0 到 6)，在做雜湊表的時候我們都常會假設資訊是 sparse 的，意思是平均分散的，這樣可以避免 link list 過長。&lt;/p&gt;
&lt;h3 id=&#34;intel-32&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#intel-32&#34;&gt;#&lt;/a&gt; Intel 32&lt;/h3&gt;
&lt;p&gt;在實務上也不是只有利用一種方法做 virtual address 的轉換， Intel 32 就是結合 segmentation 和 paging 的例子，這樣可以結合兩者的優點， segmentation 比較符合人類的分法， 把同樣性質的資料放在一起，paging 則是可以避免 external fragmentation ，所以在 Intel 32 是這樣做的，在 logical address 階段，會得到 segment 資訊和 offset，segmet 資訊稱為  selector，是一個指標，然後在到 descriptor table 中找到他的 base 和 limit ，把 offset 加上 base 之後得到 linear address ，linear assdess 再透過兩次 paging 得到 physical address ，以圖片說明下&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://i.imgur.com/lOacBea.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;以上就是記憶體的小小小科普，祝大家閱讀愉快&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://lu1hoao.github.io/2022/05/11/os/os-8/</guid>
            <title>Main Memory (上)</title>
            <link>https://lu1hoao.github.io/2022/05/11/os/os-8/</link>
            <category>OS</category>
            <category>Memory</category>
            <pubDate>Wed, 11 May 2022 21:23:28 +0800</pubDate>
            <description><![CDATA[ &lt;h3 id=&#34;概要&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#概要&#34;&gt;#&lt;/a&gt; 概要&lt;/h3&gt;
&lt;p&gt;本文主要講述 Memory 的管理，從背景、 Contiguous Memory Allocation 講到 Segmentation、Paging，對 multiprogramming 的系統而言，記憶體管理很重要，他也會大大影響到執行速度&lt;/p&gt;
&lt;h3 id=&#34;背景&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#背景&#34;&gt;#&lt;/a&gt; 背景&lt;/h3&gt;
&lt;p&gt;我們寫的程式要被執行，必須先被載入到主記憶體當中，CPU 再從 Memory (含 cache) 或 register 去讀取資訊並執行，然而 CPU 看到的這些指令與變數位址並不代表他們真正在記憶體當中的位置，舉例來說，CPU 看到「請執行第十行的指令」這個敘述不表示第十行指令的位址真的在記憶體當中的第十行， 10 這個數字是相對位址，相當於這個程式的第十行，而這個程式的第十行被儲存在記憶體的哪個位置呢？我們需要透過 Memory Management Unit ( MMU ) 搭配 Translation lookaside buffer 來做轉換 ( TLB )，示意圖如下&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://i.imgur.com/niAzWW5.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Memory Management Unit&lt;/strong&gt; (MMU) : 把虛擬地址轉成真實地址的硬體&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Translation Lookaside Buffer&lt;/strong&gt; (TLB): 告訴 MMU 怎麼轉的表 ( a cache for the MMU&#39;s virtual-to-physical translation table )&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;base-and-limit-registers&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#base-and-limit-registers&#34;&gt;#&lt;/a&gt; Base and Limit Registers&lt;/h3&gt;
&lt;p&gt;我們先來看一下簡單的 MMU 轉換例子，假設系統會提供一個 base register ，表示這個程式開端所在的記憶體位址 (真實位址)，那這個程式的每一個指令或變數的真實位址就是他們的相對位址加上這個 base register，這個 base register 又稱為 relocation register，所以可以得到&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;virtual address + relocation register = physical address&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;今天執行程式的 relocation register 和明天執行程式的 relocation register 可能不一樣，因為記憶體空間配置的情形有所差異，但如果程式碼沒有修改，今天和明天的 virtual address 應該是相同的&lt;br /&gt;
大部分時候， complier 會提供 limit register 表示這個程式最大可存取的空間，供系統去做檢查，如果發現這個程式有某個指令或變數位址超過了 relocation register + limit register 的值，我們就可以發覺這個程式應該是有誤的，他會侵犯到別人的空間，以圖片說明：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://i.imgur.com/jn5GWNf.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;那我們是甚麼時候得到相對位址甚麼時候得到絕對位址的呢？&lt;br /&gt;
這時候就要先來看看程式從寫好到被執行經過了哪些步驟&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;complier&lt;/li&gt;
&lt;li&gt;linker &amp;amp; loader&lt;/li&gt;
&lt;li&gt;execution&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在上面三步中我們是在最後一部才得到真實位址，前面兩部都只是得到相對位址，這裡也要注意所謂的程式起始位置，對不同型態資料來說就會有不同的基準值喔，以下方程式碼說明&lt;/p&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption data-lang=&#34;c&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;JUMP X&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;ADD #&lt;span class=&#34;token number&#34;&gt;4&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;LOAD Y&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;X 是指第幾行程式碼， Y 則是一個變數，他們在不同的 segment&lt;br /&gt;
 基準位址就不一樣，在 segmentation 中會有更進一步的說明&lt;/p&gt;
&lt;h3 id=&#34;swapping&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#swapping&#34;&gt;#&lt;/a&gt; Swapping&lt;/h3&gt;
&lt;p&gt;swapping 中文是交換的意思，在這裡是指當記憶體位置不足又想跑一個大程式時，我們會把優先權比較低的程式踢去 disk (Backing store) ，讓比較高優先權體積又比較大的程式先跑，這種情況其實很少發生，因為這是下下策，工程師應概要設法用比較好的記憶體管理演算法讓空間使用率最佳化。但不幸出現這種事時，我們會把低優先權程式在記憶體中的狀態原封不動地搬到 disk ，稱為 memory image ，再次啟動低優先權 process 時就不需要再透過檔案系統開啟&lt;/p&gt;
&lt;h3 id=&#34;contiguous-allocation&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#contiguous-allocation&#34;&gt;#&lt;/a&gt; Contiguous Allocation&lt;/h3&gt;
&lt;p&gt;現在我們終於可以來看一下記憶體是如何被使用的了，一般來說記憶體被分為兩大塊 (two partitions) 一塊給 OS ，一塊給我們要跑的程式，在 multiprogramming 系統中，又把放置 user process 的記憶體切成多塊，切法又可分為以下兩種：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Fixed Partition&lt;/strong&gt;&lt;br /&gt;
 顧名思義，這裡的記憶體被切成等大的片段，每個片段放置一個 process，假設現在記憶體當中有 3 個 process ，那我們就說現在 degree 是 3，但是切成等大的片段會造成空間利用率不高，對於那些所需空間小於一個片段的 process 來說，我們多給的片段他也用不到，這種被浪費掉的空間稱為 &lt;strong&gt;Interal Fragmentation&lt;/strong&gt;，對於大小超過一個片段的 process 他也放不進去無法被執行，因此這個做法還有很多變形，像是執行一個大 process 時，不需要把整個 process 都放到記憶體，只需要放正在執行的片段就可以了&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Variable-Partition&lt;/strong&gt;&lt;br /&gt;
Variable-Partition 就是把記憶體切成大小不一的片段，以符合每個 process 不同的空間需求&lt;br /&gt;
&lt;strong&gt; (1) Buddy&#39;s System：&lt;/strong&gt;&lt;br /&gt;
Buddy&#39;s system 是指讓每塊記憶體片段都是 2 的指數次方大小，比如 2、4、8、16、64，假設今天來了一個 35 大小的 process 他就選擇 64 這個記憶體片段，但假如今天 64 大小的都用完了怎麼辦呢？就選擇 128 大小的，但把 128 切成兩塊 64，一塊給 35 ，剩下的一塊就待命&lt;br /&gt;
&lt;strong&gt; (2) 一般的 variable partition ：&lt;/strong&gt;&lt;br /&gt;
就是依照 process 大小給與剛好空的空間&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;當 process 離開記憶體後他原本佔據的空間就會空出來，稱為 &lt;strong&gt;hole&lt;/strong&gt; (也可以說，沒被 process 佔據的空間都視為 hole)，當新的 process 要進來記憶體時，就從這些 hole 挑選一個適合大小給 process，怎麼挑呢？又可以分為以下幾種&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;First-fit&lt;/strong&gt;：找到第一個是大小大於或等於 proess 的 hole 就結束&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Best-fit&lt;/strong&gt;：找到大小大於或等於 process 的 hole，且這個 hole 是所有可供 process 運用的 hole 當中最小的&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Next-fit&lt;/strong&gt;：從上一個找到的 hole 作為起點，當找到第一個大小大於或等於 process 的 hole 之後就結束&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以圖片說明，假設灰色是以被占據的記憶體空間，白色是 hole，現在來了一個需要 16 大小的 proess，那根據不同的選法就會有不一樣的結果&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://i.imgur.com/BxorVjG.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;一般來說， first-fit 會讓上面的記憶體更常被選到，經常使用意味著更容易壞掉， best-fit 則需要全部搜尋一遍有點浪費時間，next-fit 算是比較折衷的方法但是也可能會選到 worst fit (適合 process 的 hole 中，最大的那一個)&lt;/p&gt;
&lt;p&gt;如果今天有一個大小為 3 的洞，和一個大小為 5 的洞，來了一個大小為 7 的 process 要怎麼辦呢？ 如果系統沒辦法透過調整記憶體中 process 的位置來解決這個問題，我們就稱這兩個洞是 &lt;strong&gt;External Fragmentation&lt;/strong&gt;，雖然是可運用的空間卻無法真正被利用。為了解決這個問題，我們需要 &lt;strong&gt;Compaction&lt;/strong&gt; ，調整記憶體中 process 的位置，讓這兩個洞合併成一個大洞供 process 使用，調整 process 位置就需要最一開始提到的 relocation code 才有辦法&lt;/p&gt;
&lt;h3 id=&#34;segmentation&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#segmentation&#34;&gt;#&lt;/a&gt; Segmentation&lt;/h3&gt;
&lt;p&gt;我們的程式是由不同的 segment 組成的，比如變數存在 data segment，程式碼存在 code segment，當我們要找出這些變數或程式碼的真實位置時，就需要取他們的虛擬位置加上 segment 資訊。&lt;br /&gt;
一般來說，logical address (virtual address) 是由兩個數字組成，一個表示他在哪一個 segment (他們的型態) ，通常為 segment-table base register (STBR，指向該 segment table 在記憶體中的位址) 和他們的 offset (位移，相當於對該 segment 起點的位移)，我們透過 segment table 可以得到 base 和 limit 資訊，進而得到 physical address ，以圖片說明&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://i.imgur.com/6BJyXtk.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;h3 id=&#34;paging&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#paging&#34;&gt;#&lt;/a&gt; Paging&lt;/h3&gt;
&lt;p&gt;Paging ，是把 process 分成大小相同的區塊稱為 page (和 segment 不同喔， 每塊 segment 大小可能不同)，然後在真實記憶體當中，我們也切成大小相同的好幾塊，稱為 frame ，一塊 frame 的體積和一塊 page 的體積大小相同，透過 page table ，把 page 資訊放到 frame 當中。這樣的做法可以避免 external fragmentation，但依然會有 internal fragmentation 以下方簡圖說明&lt;br /&gt;
 CPU 得到的 logical address (virtual address)，包含兩個數字，一個是 &lt;strong&gt;virtual page number&lt;/strong&gt; (VPN)，是一個 index ，表示這個 page 在 page table 中的位置，和一個 Page offse 該資料相對於這個 page 的起始位址位移多少，在 page table 中則會記載每一個 page table 對應到真實記憶體當中的哪一個 frame&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://i.imgur.com/Zd8yrER.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;這裡要注意從 page 對應到 memory 不一定要依照 page 的次序，舉例來說第一塊 page 不一定要對應到第一塊 frame，也可以是第五塊，因為每一塊 frame 大小都相同，所以對應到哪一塊其實沒差，隱含著一個重要訊息，&lt;strong&gt;在真實記憶體當中，一個 process 存放的空間可以是不連續的&lt;/strong&gt;，事實上 page 分類在 disk 就已經完成，後面會更詳細解說。 我們用下面例子說明空間使用情況&lt;br /&gt;
假設一個 page 是 2048 bytes，有一個 72766 bytes 的 process ，這樣他需要 36 個 pages ，但最後一個 page 沒有裝滿，會有 962 bytes 的 internal fragmentation&lt;br /&gt;
 如果一個 page 容量越大，就可能會造成越多 internal fragmentation ，如果單一 page 容量很小又會造成 page table 很大，因為他要存放這些 page 的位址，不過依電腦趨勢而言， page 的尺寸是越做越大&lt;/p&gt;
&lt;p&gt;原本想要一篇打完的，但內容好多，剩下的留到下篇，祝大家閱讀愉快&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://lu1hoao.github.io/2022/05/02/os/os-7/</guid>
            <title>Deadlocks(下)</title>
            <link>https://lu1hoao.github.io/2022/05/02/os/os-7/</link>
            <category>OS</category>
            <category>Deadlock</category>
            <pubDate>Mon, 02 May 2022 21:23:28 +0800</pubDate>
            <description><![CDATA[ &lt;h3 id=&#34;概要&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#概要&#34;&gt;#&lt;/a&gt; 概要&lt;/h3&gt;
&lt;p&gt;本篇文主要講述 deadlock prevention 和 deadlock avoidence ，前者是在開始執行之前就先預防，避免產生 deadlock ，後者則是邊執行邊看，確保走的每一步都會讓系統維持在安全狀態，不過這兩者的核心概念都是避免達到四項條件&lt;/p&gt;
&lt;h3 id=&#34;deadlock-prevention&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#deadlock-prevention&#34;&gt;#&lt;/a&gt; Deadlock prevention&lt;/h3&gt;
&lt;p&gt;我們依照四項條件逐一攻破&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Mutex Exclusion&lt;/strong&gt; 既然是互斥，一次只能允許一個 process 存取一項資源，那我們就盡考能讓資源共享化，只要不是明確規定說不可以分享的，我們都讓他分享&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Hold and Wait&lt;/strong&gt; 這個原本是說我拿到一項資源了但是還沒湊齊所有我需要的，所以我正等待著，打破這條件的方法就是規定一定要一次拿齊所有東西，不可以先拿著某些東西然後等待，要就要全拿不然就兩手空空&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;No preemption&lt;/strong&gt; 這個是指該 process 除非是自願放棄否則無法被搶先，解決該問題的方法，就是有一個 process 當自願者，當她所需的資源一直要不到時，他就自願放棄釋出他已經拿到的資源，讓系統重新分配&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Circular wait&lt;/strong&gt; ，這個是指互相等待的情況，解決這個問題的方法就是把資源編號，假設 process a 需要 1 3 資源， process b 需要 3 4 資源 process c 需要 1 4 資源，原本可能會 a 拿到 1，b 拿到  3 ，c 拿到 4 ，進而互相等待，但如果規定一定要從自己所需資源中編號小的開始拿取那麼 c 拿不到 1 ，他也無法拿 4 ，系統就不會形成 circular wait&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下來我們就來看看這些方法是如何解決 dining philiphers deadlock，下面是最一開始的程式碼&lt;/p&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption data-lang=&#34;c&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;do&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token function&#34;&gt;wait&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;chopstick&lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt;i&lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token function&#34;&gt;wait&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;chopstick&lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;i&lt;span class=&#34;token operator&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;%&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;     &lt;span class=&#34;token comment&#34;&gt;//eat&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token function&#34;&gt;signal&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;chopstick&lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt;i&lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;6&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token function&#34;&gt;signal&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;chopstick&lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt;i&lt;span class=&#34;token operator&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;%&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;7&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;   &lt;span class=&#34;token comment&#34;&gt;//think&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;8&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;span class=&#34;token keyword&#34;&gt;while&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;true&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;如果所有哲學家都先拿起自己左邊的筷子，他們永遠拿不到自己右邊的筷子，造成 deadlock。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用方法一 mutex：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我們設定一個仲裁器規定現在輪到哪個哲學家吃東西，只有在輪到他時他才可以吃，這樣一次只有一個哲學家可以吃東西，但保證大家都吃得到&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用方法 2 打破 hold and wait&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;我沒辦法一次拿兩支筷子那我就不拿了，乍看之下這個方法有解，他也確實不會造成 deadlock，但可能會引發新的問題，稱為 &lt;strong&gt;livelock&lt;/strong&gt; ，想像現在這群哲學家一個口令一個動作的全部同時舉起左邊筷子，發現無法拿起右邊，於是又全部同時一起放下，接著又全部同時憶起舉起右邊，發現無法舉起左邊，又全部同時一起放下，這樣來來回回雖然沒有 deadlock ，卻依然吃不到東西。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用方法 3 打破 No preemption：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;先把一位哲學家移出餐桌，剩下的人就可以順利執行，之後再請那位先犧牲小我的哲學家回來，所以方法 3 是行得通的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用方法 4 按照次序拿取資源：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;這樣第 n 位哲學家就沒辦法順利的吃飯，剩下的幾個人可以，那這個 deadlock 就順利被解開了&lt;/p&gt;
&lt;h3 id=&#34;deadlock-avoidence&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#deadlock-avoidence&#34;&gt;#&lt;/a&gt; Deadlock Avoidence&lt;/h3&gt;
&lt;p&gt;是先預防雖然有效，但會造成資源的使用率很低，有沒有甚麼方法可以邊做邊看呢？那就是 &lt;strong&gt;Banker&#39;s  Algorithm&lt;/strong&gt;，把作業系統想成是銀行， process 是要借貸的客戶，資源是電腦的資產，銀行應該要優先把資源借給那些&lt;strong&gt;要求沒超過自己負荷量的客戶&lt;/strong&gt;，比如總資產 2000 元，一個人想借 200 元，一個人想借 3000 元，先借兩百元的自己才不會破產，我們用表格來說明&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;已拿到&lt;/th&gt;
&lt;th&gt;所有需要的&lt;/th&gt;
&lt;th&gt;還需要的&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;P1&lt;/td&gt;
&lt;td&gt;0014&lt;/td&gt;
&lt;td&gt;0656&lt;/td&gt;
&lt;td&gt;0642&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P2&lt;/td&gt;
&lt;td&gt;1432&lt;/td&gt;
&lt;td&gt;1942&lt;/td&gt;
&lt;td&gt;0510&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P3&lt;/td&gt;
&lt;td&gt;1354&lt;/td&gt;
&lt;td&gt;1356&lt;/td&gt;
&lt;td&gt;0002&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P4&lt;/td&gt;
&lt;td&gt;1000&lt;/td&gt;
&lt;td&gt;1750&lt;/td&gt;
&lt;td&gt;0750&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;數字並不是四位數而是代表這些 process 需要四種資源，以及他們所需該資源的個數，假設電腦現在可負擔 1520 ，那他應該要先把資源給 P2， 因為 P1 他給不起，給完 P2 後他就可以把 P2 的資源收回來 (P2 已經做完了)，現在電腦資源變成 2952 可以給 P3 ，再把 P3 的資源收回來... 依此類推，如果我們可以找到一個執行順序讓每一個 process 都可以被順利執行，那我們就會稱為這是一個安全狀態，我們要確保系統永遠都會在安全狀態，走了住一步之後下一步還有路可走才不會 deadlock ，大概就是這個意思。&lt;/p&gt;
&lt;p&gt;以上就是 deadlock 的預防和避免，祝大家閱讀愉快&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://lu1hoao.github.io/2022/05/02/os/os-6/</guid>
            <title>Deadlocks(上)</title>
            <link>https://lu1hoao.github.io/2022/05/02/os/os-6/</link>
            <category>OS</category>
            <category>Deadlock</category>
            <pubDate>Mon, 02 May 2022 20:23:28 +0800</pubDate>
            <description><![CDATA[ &lt;h3 id=&#34;概要&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#概要&#34;&gt;#&lt;/a&gt; 概要&lt;/h3&gt;
&lt;p&gt;Deadlocks 是指多個 process 在執行時因為達到某些條件，使得所有 process 都無法運作只能待在原地發呆的情況，本文主要講述達成 Deadlock 的條件 (Coffman&#39;s conditions)、Handling Deadlocks、下篇則會講述 deadlock prevention (在開始執行之前就先確保 deadlock 不會發生，預防的概念) 和 deadlock avoidence&lt;/p&gt;
&lt;h3 id=&#34;resource-allocation-graph&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#resource-allocation-graph&#34;&gt;#&lt;/a&gt; Resource-Allocation Graph&lt;/h3&gt;
&lt;p&gt;在開始之前我們先來看一 下電腦資分配圖，會有助於我們對 deadlock 條件的了解，假設電腦有不同的資源型態 R1、R2、R3 ，每個型態的資源個數不一定為一，而有多個 process p1、p2、p3，每個 process 會根據自己的需求去要所需的資源，假設 p1 request R3 (p3 需要資源 3)，我們就畫一個箭頭從 p1 指向 R3，(箭頭方向很重要喔)，假設 R2 分給 pj (亦即 pj 需要 R2 且系統核准了那麼 R2 就分給 pj)，畫一個箭頭從 R2 指向 pj，得到下圖&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://i.imgur.com/P56ApDW.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;但要注意 R3 型態的資源不一定只有一個，所以如果現在又有一個 process 需要 R3 資源他未必要等待，這就好像是一間自助洗衣店裡面，有洗衣機 (假設 4 台) 有烘衣機 (假設 8 台) 有兌幣機 (假設 1 台) 有洗衣精販賣機 (假設 1 台)，今天來了兩個客人，他們一個要用洗衣機，一個要用烘衣機，那就各自用各自的，一切很順暢，但如果兩個人都要用兌幣機，就需要等待，我們待會會用 resource-allocation graph 來描述 circular wait&lt;/p&gt;
&lt;h3 id=&#34;deadlock-characterization&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#deadlock-characterization&#34;&gt;#&lt;/a&gt; Deadlock Characterization&lt;/h3&gt;
&lt;p&gt;deadlock characterization ，又稱為 Coffman&#39;s conditions，是只會造成 deadlock 的條件，以下四個條件&lt;strong&gt;同時&lt;/strong&gt;發生時就會產生 deadlock&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Mutual execlusion&lt;/strong&gt; 互斥，當一次只有一個 process 可以使用該資源物件時 (一台洗衣機一次只能給一個使用者使用)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Hold and wait&lt;/strong&gt; 某 process　需要兩個以上資源才能運作，他拿了其中一個，卻在等另一個，沒等到他也不能動（就像某人去自助洗衣店，還沒換好零錢就先把衣服丟到洗衣機裡佔位，但兌幣機前大排長龍，他沒兌到幣也不能洗）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;No preemption&lt;/strong&gt; 這個 process 是不能被搶先的，就算他握有很珍貴的資源卻執行很慢，後面的人還是不能把它的資源搶過來做，除非他自願放棄&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Circular wait&lt;/strong&gt; 循環等待， A 等 B，B 等 C，C 等 A，大家等來等去甚麼事都不能做，把 Circular wait 的 resource allocation grapg 畫出來會發現他們繞成一個圈，但不代表繞成一個圈就一定會 dwadlock 喔，如果該資源只有一件時才會 deadlock，兩者並非若且為若的關係&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;這張圖片以長方形表示資源 (不同顏色表示不同型態)，把 recource allocation 畫出來發現可以找到兩個圈，這張會造成 deadlock，因為 p1 在等 p2 ， p2 在等 p3， p3 在等 p1 或 p2&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://i.imgur.com/qWdJvjA.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;然而下面這個情況卻不一定會產生 deadlock，因為 p3 不一定要等待 p1，他也可以等 p4&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://i.imgur.com/NnFUWlX.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;h3 id=&#34;methods-for-handling-deadlocks&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#methods-for-handling-deadlocks&#34;&gt;#&lt;/a&gt; Methods for Handling Deadlocks&lt;/h3&gt;
&lt;p&gt;既然我們剛剛已經介紹 deadlock 的行程條件，接下來就來看看電腦是如何處理 deadlock 的&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;確保 deadlock 永遠不會發生，使用 deadlock prevention (事先預防) 和 deadlock avoidence (過程中避免)&lt;/li&gt;
&lt;li&gt;如果沒辦法做到上面，真的執行中遇到 deadlock 了，那就只好選一個受害者 process ，把他強制結束，釋放他原本持有的資源再重新分配&lt;/li&gt;
&lt;li&gt;最後一種就是都不要管，我作業系統不負責處理 deadlock，其實這是大多數作業系統的態度，認為避免 deadlock 是使用者的義務，然而這麼做不代表 deadlock 不重要，在網路上 deadlock 的避免就是很重要的技術&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文主要介紹了達成 deadlock 的四項條件，並從 resource-allocation 圖中辨別是否會造成 deadlock ，下篇會講解 deadlock prevention 和 deadlock avoidence ，主要就是避免系統達到四項條件，祝大家閱讀愉快&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://lu1hoao.github.io/2022/04/29/os/os-5/</guid>
            <title>Synchronization Examples</title>
            <link>https://lu1hoao.github.io/2022/04/29/os/os-5/</link>
            <category>OS</category>
            <category>Synchronization</category>
            <pubDate>Fri, 29 Apr 2022 20:23:28 +0800</pubDate>
            <description><![CDATA[ &lt;h3 id=&#34;概要&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#概要&#34;&gt;#&lt;/a&gt; 概要&lt;/h3&gt;
&lt;p&gt;上篇文章簡單介紹了 Synchronization 的解法，現在我們要來看更多會遇到同步問題的情況 (上次只簡單講了 Bounded-Buffer Problem)，這些經典問題現在都已經變成一種測試，當我們提出新的 Synchronization 方法時，就要拿這些經典問題去測試，看看我們的方法是否比前人的好。同時也會說明一些作業系統是如何支援這些 Synchronization 演算法&lt;/p&gt;
&lt;h3 id=&#34;bounded-buffer-problem&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#bounded-buffer-problem&#34;&gt;#&lt;/a&gt; Bounded-Buffer Problem&lt;/h3&gt;
&lt;p&gt;這個問題就是之前說的有 consumer 和 producer 的問題，我們在這裡把他的演算法寫得更詳細，首先會有共用變數 mutex (初值為 1)、 full ( 初值為 0 ，表示未滿)、 empty (初值為 n , 表示可以放 n 件物品)，對 producer 而言，有以下程式碼&lt;/p&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption data-lang=&#34;c&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;do&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token function&#34;&gt;wait&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;empty&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;token comment&#34;&gt;/*n-1*/&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token function&#34;&gt;wait&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;mutex&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  critical sextion&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token function&#34;&gt;signal&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;mutex&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;6&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token function&#34;&gt;signal&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;full&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;token comment&#34;&gt;/*0+1*/&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;7&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;span class=&#34;token keyword&#34;&gt;while&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;true&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;對 consumer 而言有以下程式碼&lt;/p&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption data-lang=&#34;c&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;do&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token function&#34;&gt;wait&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;full&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token function&#34;&gt;wait&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;mutex&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token function&#34;&gt;signal&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;mutex&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token function&#34;&gt;signal&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;empty&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;6&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;span class=&#34;token keyword&#34;&gt;while&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;true&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;要特別注意 empty 和 full 的位置，producer 是要進到 empty 的空間放東西，所以先把 empty 的值扣一， consumer 是到滿的地方拿東西，所以把 full 扣一。 mutex 則是要確保沒有別人在 critical section。&lt;/p&gt;
&lt;h3 id=&#34;readers-writers-problem&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#readers-writers-problem&#34;&gt;#&lt;/a&gt; Readers-Writers Problem&lt;/h3&gt;
&lt;p&gt;剛剛的 Bounded-Buffer Problem 是在描述兩個 process 都可以改值的狀況，還有一種情況是有多個 writer 和多個 reader process 的情況，同一時間可以有多個 reader ，但 writer 只能單獨存在 (writer 不能和 reader 共存也不能和其他 writer 共存)，這種問題通常有兩種解法&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;First&lt;/strong&gt; 除非 writer 被准許可以寫不然 reader 可以很自由的閱讀&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Second&lt;/strong&gt; 當 writer 想寫就寫&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;這兩種都是利用 Priority 排序，所以都會有 Starvation 的問題，第一種是 writer 會餓死，第二種是 reader 會餓死，我們來更仔細的看第一種解法，所有 process 會共用以下變數方便 mutex：&lt;strong&gt;rw_mutex (預設為 1)， mutex ( 預設為 1)、read_count (預設為 0)&lt;/strong&gt;，為甚麼要計算讀者的人數呢？因為當讀者為 0 時 (read_count=0) 就可以告訴 writer 來寫了 (要沒人看的時候才能寫，因為我們在第一種)，先來看看 writer 的程式碼&lt;/p&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption data-lang=&#34;c&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;do&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token function&#34;&gt;wait&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;rw_mutex&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    &lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token comment&#34;&gt;/*writing is performed*/&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    &lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;6&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token function&#34;&gt;signal&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;rw_mutex&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;7&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;span class=&#34;token keyword&#34;&gt;while&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;true&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;rw_mutex 是一個確定沒有其他 writer 在撰寫，也沒有 reader 在閱讀的機制 (for writer &amp;amp; reader) ，接下來看一下 reader 的程式碼&lt;/p&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption data-lang=&#34;c&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;do&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token function&#34;&gt;wait&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;mutex&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  read_count&lt;span class=&#34;token operator&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token keyword&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;read_count&lt;span class=&#34;token operator&#34;&gt;==&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    &lt;span class=&#34;token function&#34;&gt;wait&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;rw_mutex&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;6&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token function&#34;&gt;signal&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;mutex&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;7&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;8&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token comment&#34;&gt;/* 開始閱讀 */&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;9&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;10&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token function&#34;&gt;wait&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;mutex&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;11&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  read_count&lt;span class=&#34;token operator&#34;&gt;--&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;12&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token keyword&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;read_count&lt;span class=&#34;token operator&#34;&gt;==&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;13&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    &lt;span class=&#34;token function&#34;&gt;signal&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;rw_mutex&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;14&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token function&#34;&gt;signal&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;mutex&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;15&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;span class=&#34;token keyword&#34;&gt;while&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;true&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;為甚麼在進入時要先確認 mutex 呢？不是可以同時讀嗎？這是因為要修改 read_count 的數目，修改共同變數本身就是一個需要進入 critical section 的情況，所以需要有一個 mutex 機制確保一次只有一個 reader process 再更改 read_count ，當讀者是第一個讀者是他要確保已經有都興可以讀了，所以要看一下 rw_mutex 的狀態，最後一個離開的讀者要告訴 writer 好了你可以來寫了。&lt;/p&gt;
&lt;h3 id=&#34;dining-philosophers-problem&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#dining-philosophers-problem&#34;&gt;#&lt;/a&gt; Dining-Philosophers Problem&lt;/h3&gt;
&lt;p&gt;有個命題稱為飢餓的哲學家，一群哲學家坐在一圓桌，不是在思考就是在吃東西，然而這群哲學家使用筷子吃飯，他們左手邊的筷子和左邊的人共用，右手邊的筷子和右邊的人共用，就像下面的圖一樣，黃色的是桌子，藍色是筷子，總共有四位哲學家，共用四支筷子，那哲學家要如何吃飯呢？&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://i.imgur.com/Rgw1Dtg.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;我們先來看一個&lt;strong&gt;不太好&lt;/strong&gt;的解法，共用變數有 chopstick [4] (初值為 1 )&lt;/p&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption data-lang=&#34;c&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;do&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token function&#34;&gt;wait&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;chopstick&lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt;i&lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token function&#34;&gt;wait&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;chopstick&lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;i&lt;span class=&#34;token operator&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;%&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;     &lt;span class=&#34;token comment&#34;&gt;//eat&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token function&#34;&gt;signal&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;chopstick&lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt;i&lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;6&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token function&#34;&gt;signal&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;chopstick&lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt;i&lt;span class=&#34;token operator&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;%&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;7&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;   &lt;span class=&#34;token comment&#34;&gt;//think&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;8&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;span class=&#34;token keyword&#34;&gt;while&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;true&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;若全部哲學家同時舉起他們的同一手，那他們永遠無法拿到另外一手的筷子最後就卡死，所以我們修改一下&lt;/p&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption data-lang=&#34;c&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;monitor DiningPhilosopheres&lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token keyword&#34;&gt;enum&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;THINKING&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt;HUNGRY&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt;EATING&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt; state&lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  condition self&lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;pickup&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token keyword&#34;&gt;int&lt;/span&gt; i&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;6&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    state&lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt;i&lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;HUNGRY&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;7&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    &lt;span class=&#34;token function&#34;&gt;test&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;i&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;8&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    &lt;span class=&#34;token keyword&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;state&lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt;i&lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;!=&lt;/span&gt;EATING&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt; self&lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt;i&lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;wait&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;9&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;10&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;putdown&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token keyword&#34;&gt;int&lt;/span&gt; i&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;11&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    state&lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt;i&lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;THINKING&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;12&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    &lt;span class=&#34;token function&#34;&gt;test&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;i&lt;span class=&#34;token operator&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;%&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;13&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    &lt;span class=&#34;token function&#34;&gt;test&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;i&lt;span class=&#34;token operator&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;%&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;14&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;15&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;test&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token keyword&#34;&gt;int&lt;/span&gt; i&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;16&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    &lt;span class=&#34;token keyword&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;state&lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;i&lt;span class=&#34;token operator&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;%&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;!=&lt;/span&gt;EATING&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;state&lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;i&lt;span class=&#34;token operator&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;%&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;!=&lt;/span&gt;EATING&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;state&lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt;i&lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;==&lt;/span&gt;HUNGRY&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;17&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;      state&lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt;i&lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;EATING&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;18&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;      self&lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt;i&lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token function&#34;&gt;signal&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;19&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    &lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;20&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;21&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token function&#34;&gt;initialization_code&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;22&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    &lt;span class=&#34;token keyword&#34;&gt;for&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token keyword&#34;&gt;int&lt;/span&gt; i&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;i&lt;span class=&#34;token operator&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;i&lt;span class=&#34;token operator&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;23&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;      state&lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt;i&lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;THINKING&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;24&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;25&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;哲學家甚麼時候可以舉起筷子呢？他餓的時候，光餓的時候還不行，他必須先檢查左邊右邊有沒有在吃，如果沒有他就可以把狀態改成 EATING，吃飽之後要放下筷子把狀態改成 THINKING 然後換自己左邊和右邊的，這樣的架構雖然不會造成 deadlock (剛剛說的卡死) 但可能會有人餓死，若某個哲學家一直吃都不放筷子的話他左右的人就很可憐&lt;/p&gt;
&lt;h3 id=&#34;os-support&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#os-support&#34;&gt;#&lt;/a&gt; OS support&lt;/h3&gt;
&lt;p&gt;大部分的作業系統都有提供一些支原來實現 synchronization ，我們來看一些例子&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;spin-lock&lt;/strong&gt; 最早是在 Solaris 這個作業系統被提出，運用 adaptive mutexes 的觀念，意思是說，如果 lock 被一個 thread 持有，且這個 thread 正在使用 CPU 那我就等待這個 lock，如果持有 lock 的 thread 沒有在被執行，那我就先去睡了吧別等了，在 Windows 上，持有 spinlock 的 thread 不會被 preemptive&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;readers-writers locks&lt;/strong&gt; 用在 readers writers problem ，在 Solaries 中會使用 turnstiles 來安排想要獲取 lock 的 thread&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;dispatch objects&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;非-os-support&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#非-os-support&#34;&gt;#&lt;/a&gt; 非 OS support&lt;/h3&gt;
&lt;p&gt;也有一些方法是藉由其他東西來實現 synchronization，像是 transactional memory (由 memory 確保某些資料是 automically 的) 或是 open MP (展開聚集)、Functional Programming Languages&lt;/p&gt;
&lt;p&gt;以上就是 Synchronization 的更多實例，祝大家閱讀愉快&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://lu1hoao.github.io/2022/04/28/os/os-4/</guid>
            <title>Synchronization Tools (下)</title>
            <link>https://lu1hoao.github.io/2022/04/28/os/os-4/</link>
            <category>OS</category>
            <category>Synchronization</category>
            <pubDate>Thu, 28 Apr 2022 20:23:28 +0800</pubDate>
            <description><![CDATA[ &lt;h3 id=&#34;概要&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#概要&#34;&gt;#&lt;/a&gt; 概要&lt;/h3&gt;
&lt;p&gt;上一篇文章講述了實現同步的幾個演算法，核心觀念就是確保一次只有個 process 或 thread 在修改共同變數，但是 hardware-based solutions 比較難被撰寫高階語言的程式設計師使用，所以作業系統提供了 Mutex Locks、Semaphore、Monitors 這些工具，本文主要介紹這三種解法&lt;/p&gt;
&lt;h3 id=&#34;mutex-locks&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#mutex-locks&#34;&gt;#&lt;/a&gt; Mutex Locks&lt;/h3&gt;
&lt;p&gt;所謂的 Mutex Locks 就像是作業系統提供了一把鑰匙給所有要存去共同變數的 process ，誰搶到鑰匙誰就有權修改，修改完之後也要把鑰匙還回來，想拿鑰匙必須呼叫 acquire (), 還鑰匙必須呼叫 release ()，而這兩個函式在執行時都是不可被中斷的，結構如下&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;acquire lock&lt;/li&gt;
&lt;li&gt;critical section&lt;/li&gt;
&lt;li&gt;release lock&lt;/li&gt;
&lt;li&gt;remainder section&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以程式碼來看&lt;/p&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption data-lang=&#34;c&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token function&#34;&gt;acquire&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt; &lt;span class=&#34;token keyword&#34;&gt;while&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;!&lt;/span&gt;available&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt; available&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;false&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token function&#34;&gt;release&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;6&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt; available&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;true&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;7&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;然而這樣會造成 &lt;strong&gt;busy waiting&lt;/strong&gt;，在 &lt;code&gt;while(!available);&lt;/code&gt;  中，是不斷地邊等待邊檢查，因為會造成這樣的現象，我們也把這種 lock 稱為 spinlock。另外 available 這個變數只有 0 和 1 兩個值，這是一種簡單的工具&lt;/p&gt;
&lt;h3 id=&#34;semaphore&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#semaphore&#34;&gt;#&lt;/a&gt; Semaphore&lt;/h3&gt;
&lt;p&gt;semaphore 是一個整數變數，剛剛我們想要取得鑰匙必須使用 acquire，還鑰匙則是 release，在 Semaphore 中則是使用 wait and signal&lt;/p&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption data-lang=&#34;c&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token function&#34;&gt;wait&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;S&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt; &lt;span class=&#34;token keyword&#34;&gt;while&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;S&lt;span class=&#34;token operator&#34;&gt;&amp;lt;=&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt; S&lt;span class=&#34;token operator&#34;&gt;--&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token function&#34;&gt;signal&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;S&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;6&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  S&lt;span class=&#34;token operator&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;7&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;Semaphore 有 counting semaphore 和 binary semaphore，後者和 mutex 相同，前者則是整數型態，整數型態有一個好處，可以明確表示資源的數量，畢竟同步問題不只發生在修改共同變數，也可以是搶奪有限資源，舉例來說，今天要去停車場停車，發現停車場外面只寫了現在有空位或無空位就是 mutex，但如果寫剩於幾位就是 semaphore，semaphore 有可能小於 0 嗎？不可能&lt;br /&gt;
雖然執行 seamphore 大部分都是讓 semaphore 或 mutex 初值大於 0 ，但某先情況下我們可以修改初值讓 process 依照一定的次序執行&lt;br /&gt;
舉例來說 process 1 執行&lt;/p&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption data-lang=&#34;c&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;S1&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token function&#34;&gt;signal&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;synch&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;token comment&#34;&gt;//synch+1&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;process 2 執行&lt;/p&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption data-lang=&#34;c&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token function&#34;&gt;wait&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;synch&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;S2&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;這樣情況下 process 就會依照 process 1 先執行，再換 process 2 執行的次序&lt;br /&gt;
然而 semaphore 也會有 busy waiting 的問題，為甚麼 busy waiting 不好呢？因為在執行 wait () 函數時是不會被 context switch 的，等待太久就會浪費 CPU 時間。&lt;/p&gt;
&lt;h3 id=&#34;semaphore-implementation-with-no-busy-waiting&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#semaphore-implementation-with-no-busy-waiting&#34;&gt;#&lt;/a&gt; Semaphore Implementation with no Busy waiting&lt;/h3&gt;
&lt;p&gt;為了解決上面提到的問題，發展出沒有 busy waiting 的 semaphore，方法就是創立一個屬於 semaphore 的 queue，當 process 發現自己無法執行時就進到 queue 等待 ( &lt;strong&gt;block&lt;/strong&gt; ) ，執行完的 process 則會去 queue 呼叫下一個可以執行的 process ( &lt;strong&gt;wake up&lt;/strong&gt; )，此時 semaphore 也不再是一個普通的整數了，他變成這樣&lt;/p&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption data-lang=&#34;c&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;token keyword&#34;&gt;struct&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt; &lt;span class=&#34;token keyword&#34;&gt;int&lt;/span&gt; value&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt; &lt;span class=&#34;token keyword&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;token class-name&#34;&gt;process&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;*&lt;/span&gt;list&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;semaphore&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;而這個時候 value 值就有可能為負了，負表示有 process 在等待，而數字表示有幾個 process 在等待&lt;br /&gt;
原本的 wait () 和 signal () 函數則變成這樣&lt;/p&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption data-lang=&#34;c&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token function&#34;&gt;wait&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;semaphore &lt;span class=&#34;token operator&#34;&gt;*&lt;/span&gt;S&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt; S&lt;span class=&#34;token operator&#34;&gt;-&gt;&lt;/span&gt; value&lt;span class=&#34;token operator&#34;&gt;--&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt; &lt;span class=&#34;token keyword&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;S&lt;span class=&#34;token operator&#34;&gt;-&gt;&lt;/span&gt;value&lt;span class=&#34;token operator&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  add this process to S&lt;span class=&#34;token operator&#34;&gt;-&gt;&lt;/span&gt;list&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token function&#34;&gt;block&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;6&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt; &lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;7&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;8&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token function&#34;&gt;signal&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;semaphore &lt;span class=&#34;token operator&#34;&gt;*&lt;/span&gt;S&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;9&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt; S&lt;span class=&#34;token operator&#34;&gt;-&gt;&lt;/span&gt;value&lt;span class=&#34;token operator&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;10&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt; &lt;span class=&#34;token keyword&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;S&lt;span class=&#34;token operator&#34;&gt;-&gt;&lt;/span&gt;VALUE&lt;span class=&#34;token operator&#34;&gt;&amp;lt;=&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;11&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  remove a process P from S&lt;span class=&#34;token operator&#34;&gt;-&gt;&lt;/span&gt;list&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;12&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token function&#34;&gt;wakeup&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;P&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;13&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt; &lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;14&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;當我們沒寫好程式時系統可能會造成 deadlock，就是大家都卡住無法執行，下面這個情況就可能會造成 deadlock&lt;br /&gt;
 假設有 prosess p0 執行以下&lt;/p&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption data-lang=&#34;c&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token function&#34;&gt;wait&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;S&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token function&#34;&gt;wait&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;Q&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token function&#34;&gt;signal&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;S&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token function&#34;&gt;signal&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;Q&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;peocess p1 執行以下&lt;/p&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption data-lang=&#34;c&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token function&#34;&gt;wait&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;Q&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token function&#34;&gt;wait&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;S&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token function&#34;&gt;signal&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;Q&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token function&#34;&gt;signal&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;S&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;那麼對 p0 和 p1 而言，他們都拿不到他們想要的也都無法執行，就會造成系統卡住&lt;br /&gt;
如果在 semapgore queue 中安排不好，也可能會造成 starvation 。&lt;br /&gt;
另外有個名詞稱作 &lt;strong&gt;Priotity Inversion&lt;/strong&gt;，假設有一個高優先權的 process invoke 低優先權的 process 去拿取一個現在被中優先權掌握的資源，此時低優先權就會繼承高優先權的權力，順利從中優先權的 process 中搶過資源&lt;/p&gt;
&lt;h3 id=&#34;monitors&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#monitors&#34;&gt;#&lt;/a&gt; Monitors&lt;/h3&gt;
&lt;p&gt;Monitor 是一種資料型態，可以把他想成一個區域，進到這個區域之前要先排隊，進來之後也不是立刻執行喔，monitor 裡面的多個 process 只有一個能執行，在高階語言中我們使用這個架構，complier 會幫我們以 semaphores 的方式實作，monitor 大概長這樣&lt;/p&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption data-lang=&#34;c&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;monitor monitor&lt;span class=&#34;token operator&#34;&gt;-&lt;/span&gt;name&lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token comment&#34;&gt;//shared variable declarations&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt; procesdure &lt;span class=&#34;token function&#34;&gt;p1&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt; procedure  &lt;span class=&#34;token function&#34;&gt;pn&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt; initialization &lt;span class=&#34;token function&#34;&gt;code&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;6&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;在 monitor 的變數只有在 monitor 的 process 可以使用，在  monitor 的多個 process 只有一個可以執行，所以我們會使用 condition variable 來表示這些 process 的狀態，一般使用  &lt;code&gt;x.wait()&lt;/code&gt;  表示我在 monitor 中但我在等待， &lt;code&gt;x.signal()&lt;/code&gt;  則表示我在 monitor 中且我要執行，&lt;br /&gt;
為甚麼 x.signal () 示我要執行而不是我在執行呢？&lt;br /&gt;
那是因為 monitor 通常有兩種寫法，一種是當 a process  &lt;code&gt;x.signal() &lt;/code&gt; 時，b process 立刻進入  &lt;code&gt;x.wait()&lt;/code&gt; ，一種則是 a process x.signal () 但 CPU 沒有立刻執行 a process ，而是等到 b process 結束或離開 monitor 才執行，障兩種方式個又各地優缺點，端看 complier 如何實作&lt;/p&gt;
&lt;h3 id=&#34;monitor-implementation-using-semaphores&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#monitor-implementation-using-semaphores&#34;&gt;#&lt;/a&gt; Monitor Implementation Using Semaphores&lt;/h3&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption data-lang=&#34;c&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token comment&#34;&gt;//variables&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;semaphore mutex&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;token comment&#34;&gt;//(initially=1)&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;semaphore next&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;token comment&#34;&gt;//(initially=0)&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;int&lt;/span&gt; next_count&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token function&#34;&gt;wait&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;mutex&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;6&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;7&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;8&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;next_count&lt;span class=&#34;token operator&#34;&gt;&gt;&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;9&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token function&#34;&gt;signal&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;next&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;10&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;else&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;11&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token function&#34;&gt;signal&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;mutex&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;next_count 是表示有多少 process 在等待。當沒 process 等待時就把 mutex 設為 1 ， 表示大家都可以去爭奪那把鑰匙，有 process 在等待時，則呼叫等待隊伍中的下一個，至於要呼叫等待隊伍中的哪一個 process 就端看這個排序系統是使用 FCFS 或 Priority 等等，不同系統就會有不同設計&lt;/p&gt;
&lt;p&gt;以上就是 mutex、semaphores、monitors 的小科普，祝大家閱讀愉快&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://lu1hoao.github.io/2022/04/27/os/os-3/</guid>
            <title>Synchronization Tools (上)</title>
            <link>https://lu1hoao.github.io/2022/04/27/os/os-3/</link>
            <category>OS</category>
            <category>Synchronization</category>
            <pubDate>Wed, 27 Apr 2022 20:23:28 +0800</pubDate>
            <description><![CDATA[ &lt;h3 id=&#34;概要&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#概要&#34;&gt;#&lt;/a&gt; 概要&lt;/h3&gt;
&lt;p&gt;本文主要講述 Synchronization tools ，中文稱為同步，電腦中如果有兩個以上的 process 要存取同一個變數 (改變他的值) 我們必須確保這些變化是同步的不然就會造成同一個變數在不同 process 中有不同的值，本文主在討論&lt;strong&gt;確保他們是同步&lt;/strong&gt;的這個過程&lt;/p&gt;
&lt;h3 id=&#34;問題起源&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#問題起源&#34;&gt;#&lt;/a&gt; 問題起源&lt;/h3&gt;
&lt;p&gt;首先我們先來看下面這個情況，假設有兩個 process 互為 consumer 和 prodeucer 的關係，producer 完成一個任務後會把它放到 buffer ，consumer 則是會從 buffer 拿走任務，這時候就需要一個 counter 來記錄 buffer 內的任務數目，如果 counter 太小，就要叫 producer 做快一點，或者叫 consumer 拿慢一點，反之若 counter 太大，就要叫 producer 慢一點或 consumer 快一點，所以對 producer 來說他有以下程式碼&lt;/p&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption data-lang=&#34;c&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;while&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;true&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token keyword&#34;&gt;while&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;counter&lt;span class=&#34;token operator&#34;&gt;==&lt;/span&gt;BUFFER_SIZE&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  buffer&lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt;in&lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;next_produced&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  in&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;in&lt;span class=&#34;token operator&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;%&lt;/span&gt;BUFFER_SIZE&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  counter&lt;span class=&#34;token operator&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;6&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;為甚麼要  &lt;code&gt;%BUFFER_SIZE&lt;/code&gt;  呢？這是因為 buffer 的大小通常是有限的，後面放完又會從最前面開始放&lt;br /&gt;
對 consumer 來說他則有以下程式碼&lt;/p&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption data-lang=&#34;c&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;while&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;true&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token keyword&#34;&gt;while&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;counter&lt;span class=&#34;token operator&#34;&gt;==&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  next_consumed&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;buffer&lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt;out&lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  out&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;out&lt;span class=&#34;token operator&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;%&lt;/span&gt;BUFFER_SIZE&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  counter&lt;span class=&#34;token operator&#34;&gt;--&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;6&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;看起來非常合理，然而在 C 語言中， &lt;code&gt;counter++&lt;/code&gt;   &lt;code&gt;counter--&lt;/code&gt;  這樣一行程式碼，在組合語言中卻是三行&lt;/p&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption data-lang=&#34;c&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;register1&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;counter&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;register1&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;register1&lt;span class=&#34;token operator&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;counter&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;register1&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption data-lang=&#34;c&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;register2&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;counter&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;register2&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;register2&lt;span class=&#34;token operator&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;counter&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;register2&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;如果這三行沒有一口氣做完，而是做到一半就被 context switch ，那 counter 的值就不會被更新，為了解決這個問題，我們訂了 Critical section problem，對每一個 process 都有一段 code 表示 critical srction , 一旦這個 process 進到 critical section 就代表只有他能夠更改共同變數，其他人不可以更改！進到 critical section 要確認別人不在 critical section ，離開時也要把門打開讓別人可以進來，因此可以用下面程式碼範例簡單說明&lt;/p&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption data-lang=&#34;c&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;do&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  entrysection&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    critical section&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  exitsection&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    remainder section &lt;span class=&#34;token comment&#34;&gt;/* 非 critical section*/&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;6&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;h3 id=&#34;解法-petersons-solution&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#解法-petersons-solution&#34;&gt;#&lt;/a&gt; 解法 Peterson&#39;s Solution&lt;/h3&gt;
&lt;p&gt;一個正確的 critical section problem 解法，應該滿足以下三項&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Mutual Exclusion&lt;/strong&gt; ，互斥性，當我在 critical section 的時候別人都不能進&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Progress&lt;/strong&gt; ，運行順暢，大家都能很自由順利的進入 critical section 不會卡住&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Bounded Waiting&lt;/strong&gt;，等待時間短，避免有人輪不到&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Peterson&#39;s Solution 是這個問題的軟體解法，用以下程式說明&lt;/p&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption data-lang=&#34;c&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;do&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  flag&lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt;i&lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;true&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  turn&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;j&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token keyword&#34;&gt;while&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;flag&lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt;j&lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt;turn&lt;span class=&#34;token operator&#34;&gt;==&lt;/span&gt;j&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  critical section&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;6&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  flag&lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt;i&lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;false&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;7&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  remainder section    &lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;8&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;span class=&#34;token keyword&#34;&gt;while&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;true&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;假設現在輪到 process i，他想進去 critical section ，所以他就把自己的 flag 設為 1，但 critical section 不是他想進去就能進去的，必需沒有人在裡面，甚麼情況是有人在裡面？就是  &lt;code&gt;flag[j]==1&lt;/code&gt;  而且現在是 turn j (也就是說現在是輪到 process j)，那如果  &lt;code&gt;flag[j]!=1 &lt;/code&gt;  但 turn j 代表甚麼呢？代表 process j 可能已經死了，他無法自己拿起 flag 設為 1 ，那 turn i ， &lt;code&gt;flag[j]==1&lt;/code&gt;  ，代表雖然 process j 想進現在卻不是他的 turn ，他必須等到他的 turn 才能改，換句話說這是一個雙重確認的機制，有 flag 和 turn 兩個機制確保運作流暢，如果只保留這兩個中的其中一個，那上面提到三項標準的後兩項是無法滿足的&lt;/p&gt;
&lt;h3 id=&#34;synchronization-hardware&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#synchronization-hardware&#34;&gt;#&lt;/a&gt; Synchronization Hardware&lt;/h3&gt;
&lt;p&gt;有軟體解法也有硬體解法，而這兩種解法的觀念都圍繞著一個核心就是 locking ，我把自己鎖起來，沒人可以打斷我，因此硬體指令就是提供 atomic (non-interruptible)，我們用比較高階的語言來理解這些機器指令的原理，然而這其實是微指令&lt;br /&gt;
&lt;strong&gt; test_and_set Instructuon&lt;/strong&gt;&lt;br /&gt;
 (有共用的變數 lock，假設初始值是 FALSE，表示沒有其他 process 被 lock)&lt;/p&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption data-lang=&#34;c&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;boolean &lt;span class=&#34;token function&#34;&gt;test_and_set&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;boolean &lt;span class=&#34;token operator&#34;&gt;*&lt;/span&gt;target&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  boolean rv&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;*&lt;/span&gt;target&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token operator&#34;&gt;*&lt;/span&gt;target&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;TRUE&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token keyword&#34;&gt;return&lt;/span&gt; rv&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;6&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;do&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;7&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token keyword&#34;&gt;while&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token function&#34;&gt;test_and_set&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;&amp;amp;&lt;/span&gt;lock&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;8&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  critical section &lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;9&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  lock&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;false&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;10&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;span class=&#34;token keyword&#34;&gt;while&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;true&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;lock 就像軟體解法中的 turn ，而修改 target 的值就像軟體中把自己的 flag 設為 1 ，這個做法很厲害幾乎是現在通用的作法，不過這其實是 IBM 的專利，所以其他公司後來發展出 &lt;strong&gt;compare_and_swap Instruction&lt;/strong&gt; 但觀念是一樣的只是寫起來比較複雜&lt;/p&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption data-lang=&#34;c&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;compare_and_swqp&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token keyword&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;*&lt;/span&gt;value&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;token keyword&#34;&gt;int&lt;/span&gt; expected&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;token keyword&#34;&gt;int&lt;/span&gt; new_value&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token keyword&#34;&gt;int&lt;/span&gt; temp&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;*&lt;/span&gt;value&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token keyword&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;*&lt;/span&gt;value&lt;span class=&#34;token operator&#34;&gt;==&lt;/span&gt;expected&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    &lt;span class=&#34;token operator&#34;&gt;*&lt;/span&gt;value&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;new_value&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token keyword&#34;&gt;return&lt;/span&gt; temp&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;6&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;7&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;do&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;8&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &lt;span class=&#34;token keyword&#34;&gt;while&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token function&#34;&gt;compare_and_swap&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;&amp;amp;&lt;/span&gt;lock&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;9&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  critical section&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;10&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  lock&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;11&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  remainder section&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;12&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;span class=&#34;token keyword&#34;&gt;while&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;true&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;以上就是實現 Synchronization 的方法，祝大家閱讀愉快&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://lu1hoao.github.io/2022/04/25/os/os-2/</guid>
            <title>CPU Scheduling (下)</title>
            <link>https://lu1hoao.github.io/2022/04/25/os/os-2/</link>
            <category>OS</category>
            <category>scheduling</category>
            <pubDate>Mon, 25 Apr 2022 20:23:28 +0800</pubDate>
            <description><![CDATA[ &lt;h3 id=&#34;概要&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#概要&#34;&gt;#&lt;/a&gt; 概要&lt;/h3&gt;
&lt;p&gt;本篇文章會先從 multilevel queue 說起，提到 thread scheduling 和 multiprocessor 排程所需注意的事情，最後說明 real-time system。&lt;/p&gt;
&lt;h3 id=&#34;multilevel-queue&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#multilevel-queue&#34;&gt;#&lt;/a&gt; Multilevel queue&lt;/h3&gt;
&lt;p&gt;對一個 CPU 有多條 ready queue 我們就稱為 multilevel queue，為甚麼一個 CPU 需要多條 queue 呢？只有一個服務台耶？不過現實生活中也會有這種情況，一間小吃店可能在同一時刻收到現場內用訂單和來自外送平台的訂單，這兩筆訂單來自不同的排隊系統，那小吃店應該先完成哪一筆呢？或許每家店都有不同的做法，對電腦來說也是如此，通常會有 foreground (前景) 和 batch (背景) 兩條 queue，foreground 是直接面對使用者的，所以電腦採取的排程做法多是 Round Roubin ，背景則是 First Come First Served， CPU 也會放不同的比重在這兩條 queue ，比如前景佔百分之 80 ，背景佔百分之 20 ，那一個 process 可以在不同 queue 之間跑來跑去嗎？如果可以我們就稱這種 queue  為 &lt;strong&gt;multilevel feedback queue&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;thread-scheduling&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#thread-scheduling&#34;&gt;#&lt;/a&gt; Thread Scheduling&lt;/h3&gt;
&lt;p&gt;thread 中文叫做執行緒，一個 process 由很多 thread 組成，可以視為小的執行單位，對 user-level 的 thread 來說和她一起競爭  CPU 資源的是和他同屬一個 process 的其他 thread ，我們稱為 process-contention scope (PCS)，對 kernel-thread 則是 system-contention scope (SCS)，和所有系統中的 thread 競爭資源&lt;/p&gt;
&lt;h3 id=&#34;multiple-processor-scheduling&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#multiple-processor-scheduling&#34;&gt;#&lt;/a&gt; Multiple-Processor Scheduling&lt;/h3&gt;
&lt;p&gt;現在的電腦多是 Symmetric multiprocessing (SMP)，亦即每一個 CPU 都可以執行排程，所有 process 會在一條共有的 ready queue 等待被執行，或者每一個 CPU 都有獨立的 queue 存放等待被執行的 process，然而在多個 CPU 的情況下存在著 Non Uniform Memory Access， CPU 在自己家的 memory 存取速度比較快，在別人家的比較慢，換句話說，原本有一個 process 在 A CPU 執行，接著要換去 B CPU 執行， B CPU 要去 A 那裡拿資料就比較慢。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://i.imgur.com/H1vIZ8l.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;不想要讓這種事情太常發生我們就需要 &lt;strong&gt;Processor affinity&lt;/strong&gt; (親和性)，換句話說就是要儘可能讓同一個 process 在同一個 CPU 上面跑。&lt;br /&gt;
另外之前也說過，在電腦裡面不可以有倘分仔是很重要的概念，所以每個 CPU 的工作量要平均，稱為 Load balancing，有 &lt;strong&gt;Push migration&lt;/strong&gt; 和 &lt;strong&gt;Pull migration&lt;/strong&gt; 兩種做法，前者是多的給少的，比如規定每個 CPU 的工作不得超過十件， CPU A 有 12 件，他就問：有沒有人有空幫我做呀？，這時 B 舉手，他只有 6 件，所以 A 就把工作分給 B，後者則是 B 看到 A 超過 10 件，而自己沒有，於是發揮暖男精神主動跑去幫忙 A。&lt;/p&gt;
&lt;h3 id=&#34;multicore-processor&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#multicore-processor&#34;&gt;#&lt;/a&gt; Multicore Processor&lt;/h3&gt;
&lt;p&gt;對 multicore system 而言，我們通常會派發不只一條 thread 給一個 core ，因為當 processor 要去存取 memory 而耗費大量時間時我們稱為 memory stall，當一個 thread 還在等待 memory 時 (遭遇  memory stall) 我們就先執行另一個 thread，以提高速率，下圖以黃色表示 compute cycle，藍色表示 memory stall cycle&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://i.imgur.com/bpIH6SW.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;h3 id=&#34;real-time-cpu-scheduling&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#real-time-cpu-scheduling&#34;&gt;#&lt;/a&gt; Real-time CPU Scheduling&lt;/h3&gt;
&lt;p&gt;對某些電腦而言他們要執行的動作其實是週期性重複的，比如裝在衛星上的電腦，衛星拍攝一張照片、攝影機冷卻、調整衛星位置、再拍一張照片，就是這幾個動作在重複，不會突然跑出：喂，電腦給我播放 youtube 影片這樣的要求，但這些指令卻是一定要被執行的，試想核電廠的運作如果有一個指令突然沒執行，就可能會造成難以承受的災害，這種指令一定要在一個期限內完成的系統稱為  &lt;strong&gt;real-time system&lt;/strong&gt; 這種系統通常用 priority system ，&lt;strong&gt;而重複週期越短的 process 優先權越高&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以上就是 CPU 排程下篇，這裡提到的都只是簡單的小科普，其實每一個主題背後都有更深入的技術值得探討，比如為甚麼會有 memory stall 呢？因為 cache miss，不過再討論下去，篇幅就太長了，希望大家讀完有收穫。&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://lu1hoao.github.io/2022/04/23/os/os-1/</guid>
            <title>CPU Scheduling (上)</title>
            <link>https://lu1hoao.github.io/2022/04/23/os/os-1/</link>
            <category>OS</category>
            <category>scheduling</category>
            <pubDate>Sat, 23 Apr 2022 20:23:28 +0800</pubDate>
            <description><![CDATA[ &lt;h3 id=&#34;概要&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#概要&#34;&gt;#&lt;/a&gt; 概要&lt;/h3&gt;
&lt;p&gt;對現在電腦而言，排程是一件很重要的技術，打開電腦有很多事情想做，又很希望電腦趕快做完，就算沒有真的在做也給我們一點回應，讓我們知道他需要一點時間處理，本文主要探討常見的 CPU 排程方法 (包含 mulititasking 和 multiple-processor (下篇))&lt;/p&gt;
&lt;h3 id=&#34;評估標準-criteria&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#評估標準-criteria&#34;&gt;#&lt;/a&gt; 評估標準 Criteria&lt;/h3&gt;
&lt;p&gt;由於人類具有慣老闆天性，對於電腦這種不會抱怨的員工更是要求一人當三人用一刻不得閒，所以我們評估排程好壞的標準大概可以由以下幾點決定&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;CPU utilization&lt;/strong&gt; (CPU 使用率) 指的是 CPU 工作的時間，絕對是越高越好， CPU 不准休息 ，就算是在多處理器的系統，也要讓每顆 CPU 工作分配平均 (大家都很忙，不能有躺分仔的概念)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Throughput&lt;/strong&gt; (產能) 單位時間內能完成的工作越多越好，所以這個值也是越高越好&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Turnaround time&lt;/strong&gt; (從開始執行到結束的時間) 希望能夠越快做完越好，所以這個數值是越低越好&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Waiting time&lt;/strong&gt; 一個 process 在 ready queue 等待的時間，就像我們去郵局從抽號碼牌到被叫到的這段時間，等待時間越短越好，所以數值越小越好&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Response time&lt;/strong&gt; (回應時間) 這在電腦裡面是很重要的，告訴使用者我有在動啦不要再叫了！我們點兩下滑鼠打開一個程式，游標會出現一個藍色圈圈在轉，就算該軟體介面還沒出現在螢幕上，我們看到藍色圈圈也會安心不少，就不會一直瘋狂點滑鼠，回應時間越短越好，所以數值越小越好&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;了解以上幾點評估標準後我們就可以更進一步來比較各種排程方法&lt;/p&gt;
&lt;h3 id=&#34;為何需要排程&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#為何需要排程&#34;&gt;#&lt;/a&gt; 為何需要排程&lt;/h3&gt;
&lt;p&gt;multitasking 是說 CPU 可以同時一次處理好幾個 process 但這裡的同時並不是說 CPU 像千手觀音那樣，同一時刻處理好多事情，而是說 CPU 先做 A process ，做一下子後儲存 A 的狀態再換去做 B ，B 做完一些後再回來做 A ，在一段時間內多處跑的概念，到這裡人類可能會想這是哪門子的同時呀，但電腦執行的速度很快，在人類有感時間一秒內，電腦可能已經處理完好幾個 process 了，既然 CPU 是這樣在 process 之間來回走跳，決定他下一步該去哪個 process 就很重要，也是排程的精髓&lt;/p&gt;
&lt;h3 id=&#34;過程&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#過程&#34;&gt;#&lt;/a&gt; 過程&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Short-term-scheuler 會從 ready queue 挑選一個要被執行的 process 給 CPU ，這個過程稱為 Dispatch&lt;/li&gt;
&lt;li&gt;CPU 做到一個程度後 (這個程度會依據不同的排程演算法而有不一樣的條件) 做 context switch (在 context switch 之前 重複第一步驟)&lt;/li&gt;
&lt;li&gt;CPU 執行第二個 process 直到達到終止條件&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;這三步驟不斷重複直到我們把電腦關機&lt;/p&gt;
&lt;h3 id=&#34;常見演算法&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#常見演算法&#34;&gt;#&lt;/a&gt; 常見演算法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;First Come First Served&lt;/strong&gt; (FCFS) 先進先出，最直覺的排序方式，先到 ready queue 的就先執行，直到做完再換下一個，然而這樣的排程方法無法保證 waiting time 最低，以下方例子來說，有三個 process 執行時間分別是 6,4,2 ，照以下順序執行，平均等待時間為 (6+4)/3&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://i.imgur.com/BD6CXb7.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;但如果把執行順序改成這樣，平均等待時間就變成 (4+2)/6&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://i.imgur.com/n2YCvwB.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;換句話說，&lt;strong&gt;當三個 process 在差不多時間抵達時&lt;/strong&gt;，&lt;strong&gt;把時間短的作為第一個效果會比較好&lt;/strong&gt;，如果完全依照先進先出反而會在某些情況浪費時間，這樣的想法進而引發 shortest job first 的排程技術&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Shortest job first&lt;/strong&gt; (SJF) 時間短的先進行，這種排程方法是 optimal (最佳的)，能確保最短的 waiting time ，但我們要如何預測 process 的執行時間呢？假設我們現在執行第 n 個 process ，第 n+1 個 process 執行時間可預測為 (預測和真實不同)&lt;br /&gt;
&lt;img data-src=&#34;https://i.imgur.com/4WI49j3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;其中 t 表示真實的時間。&lt;br /&gt;
除了一般的 SJF 排程，還有一種是 preemptive 的 SJF，所謂的 preemptive 是搶先的，當現在出現一個比 CPU 正在執行的 process 所需時間更短的 process 時， CPU 會先把手上的工作做完再去執行他呢？還是立刻剔除現在在執行的，換到他？如果是後者稱為 preemptive，而 preemptive 的 SJF 就是 &lt;strong&gt;shortest-remaining-time-first&lt;/strong&gt;，我們以下面例子說明&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://i.imgur.com/r1Bt5gs.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://i.imgur.com/EtmSz8x.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;時間為 1 時， B 抵達因為所需時間比 A 少，所以立即停止做 A 改做 B ，時間為 5 時，B 已經做完，D 所需時間最少所以做 D ，依此類推&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Priority Scheduling&lt;/strong&gt; (優先權排序)，這種把事情程度分級的做法在生活中很常見，比如醫療上常見的檢傷分類，把最緊急最有生命危險的作為最先救助，其實 SJF 也算一種 Priority Scheduling 只是他的評估標是時間，對電腦而言常見的優先順序依序是&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;system processes&lt;/li&gt;
&lt;li&gt;interactive processes&lt;/li&gt;
&lt;li&gt;interactive editing processes&lt;/li&gt;
&lt;li&gt;batch processes&lt;/li&gt;
&lt;li&gt;student processes&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;到這裡難免有些難過 student process 竟然最低，然而平常寫程式資料量通常都很小所以跑很快 &amp;gt; &amp;lt;(老師叫我們不要灰心)&lt;br /&gt;
 Priority Scheduling 雖然很符合人的理想，事情有輕重緩急，確實本該分類，然而會造成 &lt;strong&gt;Starvation&lt;/strong&gt; ，當有大型傳染病發生時，醫院的醫療資源可能就會被大量的傳染病患者佔據，壓縮到原先非傳染病患者的資源 (比如需長時間治療的慢性病)，最後這些慢性病患者可能就會因為資源不足而病情惡化，Starvation 就是在形容這種狀況，因為優先權太低而等不到資源最後無法被執行，解決 starvation 的方法是 &lt;strong&gt;Aging&lt;/strong&gt;，每隔一段時間就提升在等待的 process 的優先權，比如 A process 原本優先權是 3 ，他在 ready queue 等一段時間後便上升為 2 ，只要等得夠久有一天一定能變成優先權最高最先被執行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Round Roubine&lt;/strong&gt;，這種排程方式在生活中也很常見，假設一群人到遊樂園玩海盜船，玩完一次 10 分鐘，覺得意猶未盡還想再玩該怎麼辦呢？就要離開遊戲區到外面重排直到又輪到自己 ，Round Roubin 就是這樣，把時間切成好幾塊，每個人執行一次，若還沒跑完再重新排，因此時間區塊的大小很重要，如果切太大，每個人都在一塊時間內就跑玩那就和 FCFS 沒兩樣，如果時間切太小塊，又會浪費太多時間在做 context switch 我們以下面例子來說明，假設每塊時間為 4&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://i.imgur.com/lhWsqX7.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://i.imgur.com/HXYWl7m.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上就是目前電腦常見的排程方式，我在下篇會提到 multi queue (多個 ready queue) 以及 multiple processor 所需的注意事項和 real-time system&lt;/p&gt;
 ]]></description>
        </item>
    </channel>
</rss>
